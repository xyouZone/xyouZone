<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>React</title>
    <url>/2022/08/23/React/</url>
    <content><![CDATA[<h2 id="state"><a href="#state" class="headerlink" title="state"></a>state</h2><p>在React中，当组件渲染完毕后，再修改组件中的变量，不会使组件重新渲染，要使得组件可以收到变量的影响，必须在变量修改后对组件进行重新渲染，这里我们就需要一个特殊变量，当这个变量被修改时，组件会重新自动渲染。</p>
<span id="more"></span>

<p>state相当于个变量，只是这个变量在react中进行了注册，React会监控这个变量的变化，当state发生变化时，会自动触发组件的重新渲染，使得我们的修改可以在页面中呈现出来。</p>
<p>在函数组件中，偶们需要通过钩子函数，获取state</p>
<p>使用钩子useState()来创建state<br><code>import &#123; useState &#125; from &quot;react&quot;</code></p>
<p>它需要一个值作为参数，这个值就是state的初始值<br>  该函数会返回一个数组</p>
<ul>
<li>数组中第一个元素，是初始值<br>  初始值只用来显示数据，直接修改不会触发组件的重新渲染</li>
<li>第二个元素，是一个函数，通常命名为serXXX<br>  这个函数用来修改state，调用其修改state后会触发组件的重新渲染，并且使用函数中的值作为新的state值。</li>
</ul>
<h3 id="state注意事项"><a href="#state注意事项" class="headerlink" title="state注意事项"></a>state注意事项</h3><p>1、只有state值发生变化时，组件才会重新渲染。<br>2、当state的值是一个对象时，修改时是新的对象去替换旧的对象，意味着类似下面这种方式是不会重新渲染的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [obj, setObj] = <span class="title function_">useState</span>(&#123;<span class="attr">name</span>: <span class="string">&#x27;aa&#x27;</span>&#125;);</span><br><span class="line">obj.<span class="property">name</span> = <span class="string">&#x27;bb&#x27;</span>;</span><br><span class="line"><span class="title function_">setObj</span>(obj);</span><br></pre></td></tr></table></figure>
<p>正确的修改方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">setObj</span>(&#123;...obj,<span class="attr">name</span>:<span class="string">&#x27;bb&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure>
<p>3、通过setState去修改state时，并不代表修改当前的state,它修改的是<strong>组件下一次渲染时state值</strong>。<br>4、setState()会触发组件的重新渲染，它是<strong>异步</strong>的。所以当调用setState()需要调用旧state的值时，一定要注意有可能会出现计算错误的情况。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">setCounter</span>(counter + <span class="number">1</span>);  <span class="comment">// 预期 1 2 3，但如果一秒内点击多次，可能第三次拿到的counter值还是1，出现错误。</span></span><br></pre></td></tr></table></figure>
<p>为了避免这种情况，可以通过为setState()传递回调函数的形式在修改state。<strong>setState()中回调函数的返回值将会成为新的state值，回调函数执行时，React会将最新的state值作为参数传递</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">setCounter</span>(<span class="function"><span class="params">prevCounter</span> =&gt;</span> prevCounter + <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<h2 id="DOM对象和useRef"><a href="#DOM对象和useRef" class="headerlink" title="DOM对象和useRef()"></a>DOM对象和useRef()</h2><p>获取原生的DOM对象</p>
<ul>
<li>可以使用传统的document来对DOM进行操作</li>
<li>可以从React处获取DOM对象<br>步骤：<br>1、创建一个存储DOM对象的容器<br>使用useRef()钩子函数<br>钩子函数注意事项：<br>①React中的钩子函数只能用于函数组件或自定义钩子<br>②钩子函数只能在函数组件中调用<br>2、将容器设置为想要获取DOM对象元素的ref属性，React会自动将当前元素的DOM对象，设置为容器current属性<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> h1Ref = <span class="title function_">useRef</span>(); <span class="comment">// h1Ref: &#123;current:&lt;h1&gt;&lt;/h1&gt;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">ref</span>=<span class="string">&#123;h1Ref&#125;</span>&gt;</span>....<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
useRef()返回的就是一个普通的JS对象：<code>&#123;current:undefined&#125;</code>,所以我们直接创建一个js对象，也可以代替useRef(),区别：我们创建的对象，组件每次重新渲染都会重新创建一个新对象，useRef()创建的对象，可以确保每次渲染获取到的都是同一个对象。因此，当你需要一个对象不会因为组件的重新渲染而改变时，使用useRef()。</li>
</ul>
<h2 id="类组件"><a href="#类组件" class="headerlink" title="类组件"></a>类组件</h2><ul>
<li>类组件的props是存储到类的实例对象中，可以直接通过实例对象访问<code>this.props</code></li>
<li>类组件中state统一存储到了实例对象的state属性中，可以通过<em>this.state</em>访问，通过<em>this.setState</em>对其进行修改。当我们通过this.setState()修改state时，React只会修改设置了的值，但是仅限于<em>直接</em>存储于state中的属性，类似对象这种属性相当于设置了一个新的对象。</li>
<li>函数组件中，响应函数直接以函数的形式定义在组件中，但是在类组件中，响应函数是以类的方法来定义</li>
<li>类组件中获取DOM对象，使用React提供的createRef<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> divRef = <span class="title class_">React</span>.<span class="title function_">createRef</span>();</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="portal"><a href="#portal" class="headerlink" title="portal"></a>portal</h2><ul>
<li>组件默认会作为父组件的后代渲染到页面中，但是有些情况下，这种方式会带来一些问题。（子组件层级再高也不会超过父组件）</li>
<li>通过portal可以将组件渲染到页面的指定位置</li>
<li>使用方法：<br> 1、在index.html添加一个新的元素<br> 2、修改组件的渲染方式<pre><code>- 通过ReactDOM.createPortal()作为返回值创建元素。
- 参数：1、jsx(修改前return后的代码)；2、目标位置；
</code></pre>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.html</span></span><br><span class="line">&lt;div id=<span class="string">&quot;demo&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// backdrop.js</span></span><br><span class="line"><span class="keyword">const</span> backdropRoot = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;demo&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Backdrop</span> = (<span class="params">props</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">ReactDOM</span>.<span class="title function_">createPortal</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">   xxxxxx</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>,backdropRoot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Fragment"><a href="#Fragment" class="headerlink" title="Fragment"></a>Fragment</h2><p>React.Fragment是一个专门用来作为父容器的组件，它只会将它里面的子元素直接返回，不会创建任何多余的元素。当我们希望有一个父容器，但同时不希望父容器在网页中产生多余的结构时，可以使用。</p>
<h2 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h2><p>Context相当于一个公共的存储空间，我们可以将多个组件中都需要访问的数据统一存储到一个Context中,这样无需通过props逐层传递，即可使组件访问到这些数据通过React.createContext()创建context</p>
<p>使用方法一：</p>
<ul>
<li>1、引入context</li>
<li>2、使用 <strong>Xxx.Consumer</strong> 组件来创建元素<br>Consumer 的标签体需要一个回调函数<br>它会将context设置为回调函数的参数，通过参数就可以访问到context中存储的数据<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// testContext.js</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">TestContext</span> = <span class="title class_">React</span>.<span class="title function_">createContext</span>(&#123;</span><br><span class="line">    <span class="attr">content</span>: <span class="string">&#x27;这是公共的数据&#x27;</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">TestContext</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">TestContext</span> <span class="keyword">from</span> <span class="string">&quot;../store/testContext&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">A</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">TestContext.Consumer</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            &#123;(ctx)=&gt;&#123;</span></span><br><span class="line"><span class="language-xml">               return <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                   &#123;ctx.name&#125; - &#123;ctx.age&#125;</span></span><br><span class="line"><span class="language-xml">               <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            &#125;&#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">TestContext.Consumer</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
使用方法二：</li>
<li>1.导入Context</li>
<li>2.使用钩子函数useContext()获取到context，<em>useContext() 需要一个Context作为参数</em>，它会将Context中数据获取并作为返回值返回</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// B.js</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">B</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用钩子函数获取Context</span></span><br><span class="line">    <span class="keyword">const</span> ctx = <span class="title function_">useContext</span>(<span class="title class_">TestContext</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            &#123;ctx.name&#125; -- &#123;ctx.age&#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Xxx.Provider表示数据的<strong>生产者</strong>，可以使用它来指定Context中的数据,通过value来指定Context中存储的数据，这样一来，在该组件的<strong>所有的子组件</strong>中都可以通过Context来访问它所指定数据</p>
<p>当我们通过Context访问数据时，他会读取离他<strong>最近</strong>的Provider中的数据，如果没有Provider，则读取Context中的默认数据。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;A /&gt; <span class="comment">// A没有Provider,获取content为testContext.js定义的&#x27;这是公共的数据&#x27;</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">TestContext.Provider</span> <span class="attr">value</span>=<span class="string">&#123;&#123;content:</span> &#x27;<span class="attr">第一层数据</span>&#x27;&#125;&#125; &gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">TestContext.Provider</span> <span class="attr">value</span>=<span class="string">&#123;&#123;content:</span> &#x27;<span class="attr">第二层数据</span>&#x27;&#125;&#125; &gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">B</span>/&gt;</span> // B里面获取content为&quot;第二层数据&quot;</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">TestContext.Provider</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">TestContext.Provider</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h2 id="setState的执行过程"><a href="#setState的执行过程" class="headerlink" title="setState的执行过程"></a>setState的执行过程</h2><p>setState()实际调用dispatchSetDate(),会检查组件当前处于哪个阶段。<br>实际组件存在两个阶段：<strong>渲染阶段</strong>和<strong>非渲染阶段</strong><br>渲染阶段：元素还没渲染到页面中，函数组件的函数体会执行一遍；<strong>此时setState不会检查state值是否相同</strong><br>非渲染阶段：元素已经渲染到页面中，<strong>此时setState会检查state值是否相同</strong>。</p>
<ul>
<li>如果值不相同，则会对组件进行重新渲染。</li>
<li>如果值相同，不对组件进行重新渲染（在一些情况下会继续执行当前组件的渲染，但是这个渲染不会触发其子组件的渲染，这次渲染不会产生实际的效果，这种情况通常发生在值第一次相同时）。</li>
</ul>
<h2 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h2><p><code>useEffect()</code>是一个钩子函数，需要一个函数作为参数，这个作为参数的函数，将会在组件渲染完毕后执行，在开发中，可以将那些会产生副作用的代码编写到useEffect的回调函数中，这样就可以避免这些代码影响到组件的渲染</p>
<ul>
<li>默认情况下，useEffect()中的函数，会在组件渲染完成后调用，并且是每次渲染完成后都会调用。在useEffect()可以传递一个第二个参数，第二个参数是一个数组，在数组中可以指定Effect的依赖项，指定后<strong>只有当依赖发生变化时，Effect才会被触发</strong>。</li>
<li>通常会将Effect中使用的所有的局部变量都设置为依赖项，这样一来可以确保这些值发生变化时，会触发Effect的执行。像setState()是由钩子函数useState()生成的，useState()会确保组件的每次渲染都会获取到相同setState()对象(即setCount()这种函数是固定不变的)，所以setState()方法可以不设置到依赖中。</li>
<li>如果依赖项设置了一个空数组，则意味Effect只会在组件初始化时触发一次。</li>
<li>在Effect的回调函数中，可以指定一个函数作为返回值，这个函数可以称其为清理函数，它会在<span style="color:red;"><em>下次Effect执行前调用</em></span>，<strong>可以在这个函数中，做一些工作来清除上次Effect执行所带来的的影响</strong><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> timer = <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Effect触发了！&#x27;</span>);</span><br><span class="line">      props.<span class="title function_">onFilter</span>(keyword);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">clearTimeout</span>(timer); <span class="comment">// 清除上一次effect的定时器</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">&#125;, [keyword]);</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>V8引擎的工作原理</title>
    <url>/2022/08/23/V8%E5%BC%95%E6%93%8E%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>我们知道了V8的演进历史，知道目前V8的核心部分为：<br /><strong>解析器（Parser）<br />解释器（Ignition）<br />优化编译器（TurboFan）</strong><br />1.V8脚本引擎的由来。<br />2. V8脚本引擎的演进。<br />3. V8核心模块：解析器，解释器，优化编译器。<br><a name="qJLPh"></a></p>
<span id="more"></span>
<h3 id="V8是怎么执行JavaScript代码的？"><a href="#V8是怎么执行JavaScript代码的？" class="headerlink" title="V8是怎么执行JavaScript代码的？"></a>V8是怎么执行JavaScript代码的？</h3><p>当V8执行JavaScript源码时，首先解析器会把源码解析为<strong>抽象语法树</strong>（Abstract Syntax Tree），解释器再将AST翻译为字节码，一遍解释一遍执行。<br />在此过程中，解释器会记特定代码片段的运行次数，如果代码运行次数超过某个阈值，那么该段代码就被标记为热代码，并将运行信息反馈给优化编译器。<br />优化编译器根据反馈信息，优化并编译字节码，最终生成优化后的机器码，当该段代码再次执行时，不用再次解释，提升了效率。<br />这种在运行时编译代码的技术称之为JIT(即时编译)，通过JIT可以极大提升JavaScript代码的执行性能。<br><a name="vt4Vf"></a></p>
<h3 id="简单介绍每个的作用"><a href="#简单介绍每个的作用" class="headerlink" title="简单介绍每个的作用"></a>简单介绍每个的作用</h3><ul>
<li>解析器将 JavaScript 源码解析为 AST，解析过程分为词法分析和语法分析，V8 通过预解析提升解析效率；</li>
<li>解释器 Ignition 根据 AST 生成字节码并执行。这个过程中会收集执行反馈信息，交给 TurboFan 进行优化编译；</li>
<li>TurboFan 根据 Ignition 收集的反馈信息，将字节码编译为优化后的机器码，后续 Ignition 用优化机器码代替字节码执行，进而提升性能。<br><a name="sOObc"></a><h4 id="解析器（Parser）如何把源码转成AST？"><a href="#解析器（Parser）如何把源码转成AST？" class="headerlink" title="解析器（Parser）如何把源码转成AST？"></a>解析器（Parser）如何把源码转成AST？</h4>让V8执行我们的编写的源码，就要将源码装换成V8能理解的格式。V8会先把源码解析为抽象语法树（AST），这是用来表示源码的树形结构的对象，这个过程称之为<strong>解析（Parsing）</strong>。<br />解析和编译过程的性能非常重要，V8只有等编译完成后才能运行代码。解析过程如下图：</li>
</ul>
<p><img src="/images/v801.png"><br />分为两部分：</p>
<ol>
<li>词法分析：将字符流转换为tokens，字符流就是我们编写的一行行代码，token是指语法上不能再分割的最小单位（可能是单个字符，也可能是字符串）图中的Scanner就是V8的<strong>词法分析器</strong>。</li>
<li>语法分析：根据语法规则，将tokens组成一个有嵌套层级的AST，在此过程，如果源码不符合语法规范，解析过程就会终止，并抛出语法错误。图中的Parser和Pre-Parse都是V8的<strong>语法分析器</strong>。<br><a name="qchFZ"></a><h5 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h5>在V8中，Scanner负责接收Unicode字符流，并将其解析为tokens，提供给解析器使用。比如 var a = 1;，这行代码经过词法分析后的tokens是这样：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;type&quot;</span>: <span class="string">&quot;Keyword&quot;</span>,</span><br><span class="line">        <span class="string">&quot;value&quot;</span>: <span class="string">&quot;var&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;type&quot;</span>: <span class="string">&quot;Identifier&quot;</span>,</span><br><span class="line">        <span class="string">&quot;value&quot;</span>: <span class="string">&quot;a&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;type&quot;</span>: <span class="string">&quot;Punctuator&quot;</span>,</span><br><span class="line">        <span class="string">&quot;value&quot;</span>: <span class="string">&quot;=&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;type&quot;</span>: <span class="string">&quot;Numeric&quot;</span>,</span><br><span class="line">        <span class="string">&quot;value&quot;</span>: <span class="string">&quot;1&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;type&quot;</span>: <span class="string">&quot;Punctuator&quot;</span>,</span><br><span class="line">        <span class="string">&quot;value&quot;</span>: <span class="string">&quot;;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
包含了五个tokens：</li>
</ol>
<ul>
<li><p>关键字 var</p>
</li>
<li><p>标识符 a</p>
</li>
<li><p>赋值运算符 =</p>
</li>
<li><p>数值 1</p>
</li>
<li><p>分隔符 ；<br><a name="OuGtq"></a></p>
<h5 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h5><p>接下来，V8的解析器会通过语法分析，根据tokens生成AST，var a = 1; 这行代码生成的AST的JSON结构如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;type&quot;</span>: <span class="string">&quot;Program&quot;</span>,</span><br><span class="line">  <span class="string">&quot;start&quot;</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="string">&quot;end&quot;</span>: <span class="number">10</span>,</span><br><span class="line">  <span class="string">&quot;body&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;type&quot;</span>: <span class="string">&quot;VariableDeclaration&quot;</span>,</span><br><span class="line">      <span class="string">&quot;start&quot;</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="string">&quot;end&quot;</span>: <span class="number">10</span>,</span><br><span class="line">      <span class="string">&quot;declarations&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="string">&quot;type&quot;</span>: <span class="string">&quot;VariableDeclarator&quot;</span>,</span><br><span class="line">          <span class="string">&quot;start&quot;</span>: <span class="number">4</span>,</span><br><span class="line">          <span class="string">&quot;end&quot;</span>: <span class="number">9</span>,</span><br><span class="line">          <span class="string">&quot;id&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;type&quot;</span>: <span class="string">&quot;Identifier&quot;</span>,</span><br><span class="line">            <span class="string">&quot;start&quot;</span>: <span class="number">4</span>,</span><br><span class="line">            <span class="string">&quot;end&quot;</span>: <span class="number">5</span>,</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: <span class="string">&quot;a&quot;</span></span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="string">&quot;init&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;type&quot;</span>: <span class="string">&quot;Literal&quot;</span>,</span><br><span class="line">            <span class="string">&quot;start&quot;</span>: <span class="number">8</span>,</span><br><span class="line">            <span class="string">&quot;end&quot;</span>: <span class="number">9</span>,</span><br><span class="line">            <span class="string">&quot;value&quot;</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="string">&quot;raw&quot;</span>: <span class="string">&quot;1&quot;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="string">&quot;kind&quot;</span>: <span class="string">&quot;var&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="string">&quot;sourceType&quot;</span>: <span class="string">&quot;module&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>对生成AST内容感兴趣的可以在 <a href="https://link.juejin.cn/?target=https://astexplorer.net/">astexplorer.net/</a> 中查看。<br />但是，对于一份JavaScript源码，如果所有的源码在执行前都要解析才能执行，那会面临一下问题。</p>
</li>
<li><p><strong>代码执行时间变长</strong>：一次性解析所有代码，必然会增加代码的运行时间。</p>
</li>
<li><p><strong>消耗更多内存</strong>：解析完的AST，以及根据AST编译后的字节码都会存放在内存中，必然会占用更多内存空间。</p>
</li>
<li><p><strong>占用磁盘空间</strong>：编译后的代码会缓存在磁盘上，占用磁盘空间。</p>
</li>
</ul>
<p>所以，现在主流JavaScript引擎都实现了延迟解析（Lazy Parsing）。<br><a name="KWBQo"></a></p>
<h5 id="延迟解析"><a href="#延迟解析" class="headerlink" title="延迟解析"></a>延迟解析</h5><p>延迟解析的思想：在解析过程中，对于不是立即执行的函数，只进行<strong>预解析（Pre Parser）</strong>,只有当函数调用时，才对函数进行全量解析。<br />进行预解析时，只验证函数语法是否有效，解析函数声明、确定函数作用域。不生成AST，实现预解析的是Pre-Parser解析器。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> res = a + b;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> c = <span class="number">2</span>;</span><br><span class="line"><span class="title function_">foo</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>由于 Scanner 是按字节流从上往下一行行读取代码的，所以 V8 解析器也是从上往下解析代码。当 V8 解析器遇到函数声明 foo 时，发现它不是立即执行，所以会用 Pre-Parser 解析器对其预解析，过程中只会解析函数声明，不会解析函数内部代码，不会为函数内部代码生成 AST。<br />然后 Ignition 解释器会把 AST 编译为字节码并执行，解释器会按照自上而下的顺序执行代码，先执行 var a = 1;  和 var c = 2; 两个赋值表达式，然后执行函数调用 foo(1, 2) ，这时 Parser 解析器才会继续解析函数内的代码、生成 AST，再交给 Ignition 解释器编译执行。</p>
<blockquote>
<p><a name="Yk77z"></a></p>
</blockquote>
<h4 id="解释器（Ignition）如何将-AST翻译为字节码并执行？"><a href="#解释器（Ignition）如何将-AST翻译为字节码并执行？" class="headerlink" title="解释器（Ignition）如何将 AST翻译为字节码并执行？"></a>解释器（Ignition）如何将 AST翻译为字节码并执行？</h4><p>在V8架构的演进中，<a href="https://juejin.cn/post/7060870761120006157">浅谈V8脚本引擎的工作原理（二.V8脚本引擎的演进）</a>提到的V8为了解决内存占用问题，引入了字节码。如图，通常一个几十KB的文件，转换为机器码可能就是几十兆，这回消耗巨大内存。<br /><img src="/images/v802.png"><br><a name="LciFb"></a></p>
<h5 id="什么是字节码"><a href="#什么是字节码" class="headerlink" title="什么是字节码"></a>什么是字节码</h5><p>V8的字节码是对机器码的抽象，语法与汇编有些类似，我们可以把V8字节码看做一个个指令，这些指令组合到一起实现我们编写的功能，采用和物理CPU相同的计算模型进行设计。JavaScript源码的任何功能都可以等价转换成字节码的组合。字节码生成其实是遍历树的过程，V8定义了几百个字节码，可以在V8解释器头文件中查看到所有字节码<a href="https://link.juejin.cn/?target=https://github.com/v8/v8/blob/master/src/interpreter/bytecodes.h">bytecodes.h</a>。<br />解释器在执行字节码时，主要使用通用寄存器和累加寄存器，函数参数和局部变量都保存在通用寄存器中r0,r1，累加寄存器用于保存中间结果（accumulator register）。<br />举例说明字节码执行流程。 首先定义一个含有三个形参的函数f，函数功能就是对参数进行计算，并返回值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">a, b, c</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> d = c - <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">return</span> a + d * b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">f</span>(<span class="number">5</span>, <span class="number">2</span>, <span class="number">150</span>);</span><br></pre></td></tr></table></figure>
<p>假设我们以实参5、2、150调用函数，则解释器会把函数编译为字节码。<br />可以通过node –print-bytecode index.js 来查看JavaScript文件生成的字节码。(会生成非常多，取了最后一段重要的)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$ node --print-bytecode index.<span class="property">js</span></span><br><span class="line">... </span><br><span class="line">[generated bytecode <span class="keyword">for</span> <span class="attr">function</span>: f (<span class="number">0x242cd33a35b9</span> &lt;<span class="title class_">SharedFunctionInfo</span> f&gt;)]</span><br><span class="line"><span class="title class_">Parameter</span> count <span class="number">4</span></span><br><span class="line"><span class="title class_">Register</span> count <span class="number">1</span></span><br><span class="line"><span class="title class_">Frame</span> size <span class="number">8</span></span><br><span class="line">   <span class="number">32</span> S&gt; <span class="number">0x242cd33a3e06</span> @    <span class="number">0</span> : <span class="number">25</span> <span class="number">02</span>             <span class="title class_">Ldar</span> a2</span><br><span class="line">   <span class="number">34</span> E&gt; <span class="number">0x242cd33a3e08</span> @    <span class="number">2</span> : <span class="number">41</span> <span class="number">64</span> <span class="number">00</span>          <span class="title class_">SubSmi</span> [<span class="number">100</span>], [<span class="number">0</span>]</span><br><span class="line">         <span class="number">0x242cd33a3e0b</span> @    <span class="number">5</span> : <span class="number">26</span> fb             <span class="title class_">Star</span> r0</span><br><span class="line">   <span class="number">43</span> S&gt; <span class="number">0x242cd33a3e0d</span> @    <span class="number">7</span> : <span class="number">25</span> <span class="number">03</span>             <span class="title class_">Ldar</span> a1</span><br><span class="line">   <span class="number">56</span> E&gt; <span class="number">0x242cd33a3e0f</span> @    <span class="number">9</span> : <span class="number">36</span> fb <span class="number">02</span>          <span class="title class_">Mul</span> r0, [<span class="number">2</span>]</span><br><span class="line">   <span class="number">52</span> E&gt; <span class="number">0x242cd33a3e12</span> @   <span class="number">12</span> : <span class="number">34</span> <span class="number">04</span> <span class="number">01</span>          <span class="title class_">Add</span> a0, [<span class="number">1</span>]</span><br><span class="line">   <span class="number">60</span> S&gt; <span class="number">0x242cd33a3e15</span> @   <span class="number">15</span> : aa                <span class="title class_">Return</span></span><br><span class="line"><span class="title class_">Constant</span> pool (size = <span class="number">0</span>)</span><br><span class="line"><span class="title class_">Handler</span> <span class="title class_">Table</span> (size = <span class="number">0</span>)</span><br><span class="line"><span class="title class_">Source</span> <span class="title class_">Position</span> <span class="title class_">Table</span> (size = <span class="number">14</span>)</span><br><span class="line"><span class="number">0x242cd33a3e19</span> &lt;<span class="title class_">ByteArray</span>[<span class="number">14</span>]&gt;</span><br></pre></td></tr></table></figure>
<p>当解释器执行代码时，会把参数分别加载到a0、a1、a2寄存器上（图中 accumulator 表示累加寄存器）然后逐行执行字节码。<br /><img src="/images/v803.png"></p>
<ul>
<li>读取形参 c 并做出计算</li>
<li>Ldar a2: Ldar表示将寄存器的值加载到累加器的操作。a2是加载的数值，加载后，accumulator的值为150。</li>
</ul>
<p><img src="/images/v804.png"></p>
<ul>
<li>将计算结果放入累加寄存器中。</li>
<li>SubSmi [100], [0]：SubSmi [100] 表示将累加寄存器的值减少 100，这时 accumulator 的值就变为了 50，[0] 反馈向量 (FeedBack Vector) 的索引，反馈向量记录了函数在执行过程中的一些关键的中间数据。</li>
</ul>
<p><img src="/images/v805.png"></p>
<ul>
<li>将累加寄存器的值放到r0中临时记录 也是变量b的值</li>
<li>Star r0：表示把累加器中的值保存到寄存器 r0 中，这时 r0 的值就变为了 50。</li>
</ul>
<p><img src="/images/v806.png"></p>
<ul>
<li>读取a + d * b语句，先执行d * b</li>
<li>Ldar a1:表示将寄存器a1的值加载到累加寄存器，这时accumulator的值变为2。</li>
</ul>
<p><img src="/images/v807.png"></p>
<ul>
<li>继续执行d * b的第二个动作</li>
<li>Mul r0,[2]：Mul r0 表示将accumulator的值与 r0 寄存器的值相乘，并把结果再次放入累加寄存器，其中 [2] 同样是反馈向量，执行完毕后，accumulator 的值就变为了 100。</li>
</ul>
<p><img src="/images/v808.png"></p>
<ul>
<li>执行a + 100的动作</li>
<li>Add a0, [1]：Add a0 表示将累加寄存器的值与 a0 寄存器的值相加，并将结果再次放入累加寄存器，这时 accumulator 的值就变为了 105。</li>
</ul>
<p><img src="/images/v809.png"></p>
<ul>
<li>Return：表示结束当前函数的执行，并返回累加寄存器中的值，函数执行结果是 105。</li>
</ul>
<p>这是解释器执行字节码的简单过程（中间省略了对AST遍历翻译成的字节码的环节），但依旧需要对字节码转换为机器码，CPU只识别机器码。</p>
<p>看似多了一层字节码的转换感觉效率低了，但相比于机器码，字节码的优势是更方便进行性能优化，最主要是由优化编译器编译热点代码。基于字节码的优化的架构性能远超直接转为机器码的架构性能。<br />前面提到Ignition解释器在执行的过程中，会标记重复执行的热点代码交给TurboFan生成效率更高的机器码，接下来看看TurboFan是如何工作的。<br><a name="QfgVh"></a></p>
<h4 id="优化编译器（TuboFan）的工作原理"><a href="#优化编译器（TuboFan）的工作原理" class="headerlink" title="优化编译器（TuboFan）的工作原理"></a>优化编译器（TuboFan）的工作原理</h4><p>V8在提示JavaScript性能方面做了很多优化工作,其中最主要的有内联和逃逸分析两种算法。<br><a name="iJeML"></a></p>
<h5 id="内敛（inlining）"><a href="#内敛（inlining）" class="headerlink" title="内敛（inlining）"></a>内敛（inlining）</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">three</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">add</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先我们定义了一个求和函数 add ，函数有两个参数 x 和 y，然后定义了函数 three ，并在函数 three 中调用 add 函数。<br />如果不经优化，直接编译该段代码，则会分别生成两个函数的机器码。但为了进一步提升性能，TurboFan优化编译器首先会对以上两个函数进行内联，然后再编译。<br />由于函数 three 内部的行为就是求 1 和 2 的和，所以上面的代码就等价于下面的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">three</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">add</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更进一步，由于函数 three_add_inlined 中 x 和 y 的值都是确定的，所以 three_add_inlined 还可以进一步优化，直接返回结果 3 ：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">three_add_const_folded</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/v810.png"><br />通过内联，可以降低复杂度、消除冗余代码、合并常量，并且内联技术通常也是逃逸分析的基础。那什么又是逃逸分析呢？<br><a name="FlH4X"></a></p>
<h5 id="逃逸分析（Escape-Analysis）"><a href="#逃逸分析（Escape-Analysis）" class="headerlink" title="逃逸分析（Escape Analysis）"></a>逃逸分析（Escape Analysis）</h5><p>分析对象的生命周期是否仅限于当前函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">x</span> = x;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">y</span> = y;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">distance</span>(<span class="params">that</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">abs</span>(<span class="variable language_">this</span>.<span class="property">x</span> - that.<span class="property">x</span>)</span><br><span class="line">         + <span class="title class_">Math</span>.<span class="title function_">abs</span>(<span class="variable language_">this</span>.<span class="property">y</span> - that.<span class="property">y</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">manhattan</span>(<span class="params">x1, y1, x2, y2</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> a = <span class="keyword">new</span> <span class="title class_">Point</span>(x1, y1);</span><br><span class="line">  <span class="keyword">const</span> b = <span class="keyword">new</span> <span class="title class_">Point</span>(x2, y2);</span><br><span class="line">  <span class="keyword">return</span> a.<span class="title function_">distance</span>(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们定义了一个 Point  类，用于表示某个点的坐标，类中有个 distance 方法，用来计算两个点之前的曼哈顿距离。<br />然后我们在 manhattan 函数中 new 了两个点， a 和 b ，并计算 a b 的曼哈顿距离。TurboFan 首先会通过内联，将 manhattan 函数转换为下面这样的函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">manhattan_inlined</span>(<span class="params">x1, y1, x2, y2</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> a = &#123;<span class="attr">x</span>:x1, <span class="attr">y</span>:y1&#125;;</span><br><span class="line">  <span class="keyword">const</span> b = &#123;<span class="attr">x</span>:x2, <span class="attr">y</span>:y2&#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">abs</span>(a.<span class="property">x</span> - b.<span class="property">x</span>)</span><br><span class="line">       + <span class="title class_">Math</span>.<span class="title function_">abs</span>(a.<span class="property">y</span> - b.<span class="property">y</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再接下来就会对 manhattan_inlined 中的对象进行逃逸分析。什么样的对象会被认为是“未逃逸”的呢？主要有以下几个条件：</p>
<ul>
<li>对象在函数内部定义；</li>
<li>对象在作用域函数内部，如：没有被返回、没有传递应用给其他函数等。</li>
</ul>
<p>在 manhattan_inlined 中，变量 a b 都是函数内的普通对象，所以它们都是“未逃逸”对象。那么我们就可以对函数中的对象进行替换，使用标量替换掉对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">manhattan_scalar_eplacement</span>(<span class="params">x1, y1, x2, y2</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> a_x = x1;</span><br><span class="line">  <span class="keyword">var</span> a_y = y1;</span><br><span class="line">  <span class="keyword">var</span> b_x = x2;</span><br><span class="line">  <span class="keyword">var</span> b_y = y2;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">abs</span>(a_x - b_x)</span><br><span class="line">       + <span class="title class_">Math</span>.<span class="title function_">abs</span>(a_y - b_y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样函数内就不再有对象定义，取而代之的是 a_x a_y b_x b_y ，且直接来源于函数参数。<br />这样做的好处是，我们可以直接将变量加载到寄存器上，不再需要从内存中访问对象属性了，提升了执行效率的同时还减少了内存使用。</p>
]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>vue3基础</title>
    <url>/2022/08/28/vue3%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h3 id="Vue应用实例"><a href="#Vue应用实例" class="headerlink" title="Vue应用实例"></a>Vue应用实例</h3><p>当使用Vue3脚手架生成项目后，我们可以在main.js中看到这么一段代码：</p>
<span id="more"></span>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./index.css&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">createApp</span>(<span class="title class_">App</span>).<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>首先是<code>createApp</code>,在vue中，每个Vue的应用都是通过createApp函数创建的一个新的应用实例。而我们引入的<code>App.vue</code>则被称为<strong>根组件</strong>，每个应用都需要一个根组件，其他组件将作为其子组件。<code>createApp(App)</code>这个代码就是将APP作为根组件生成一个应用实例，应用实例必须在调用了<code>.mount()</code> 方法后才会渲染出来。该方法接收一个“容器”参数，可以是一个实际的 DOM 元素或是一个 CSS 选择器字符串：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// app.vue</span></span><br><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line">app.<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>应用根组件的内容将会被渲染在容器元素里面。容器元素自己将不会被视为应用的一部分。</p>
<p>.mount() 方法应该始终在整个应用配置和资源注册完成后被调用。同时请注意，不同于其他资源注册方法，它的返回值是根组件实例而非应用实例。</p>
<h3 id="reactive"><a href="#reactive" class="headerlink" title="reactive"></a>reactive</h3><p>reactive通常用来创建<strong>对象或者数组</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; reactive &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> state = <span class="title function_">reactive</span>(&#123; <span class="attr">count</span>: <span class="number">0</span> &#125;)</span><br></pre></td></tr></table></figure>
<p>reactive使用了Proxy实现响应式，返回的是一个原始对象的Proxy，它与原始对象并不是相等的。</p>
<blockquote>
<p>对同一个原始对象调用 reactive() 会总是返回同样的代理对象，而对一个已存在的代理对象调用 reactive() 会返回其本身：</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在同一个对象上调用 reactive() 会返回相同的代理</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">reactive</span>(raw) === proxy) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在一个代理上调用 reactive() 会返回它自己</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">reactive</span>(proxy) === proxy) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>reactive的局限：</p>
<ol>
<li>仅对对象类型有效（对象、数组、map、set），对string、number、boolean这样的原始类型无效。</li>
<li><code>Vue的响应式系统是通过属性访问进行追踪的</code>，当我们用一个对象去替换了一个响应式对象，或者将响应式对象的属性进行解构时，将会失去响应式。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> state = <span class="title function_">reactive</span>(&#123; <span class="attr">count</span>: <span class="number">0</span> &#125;)</span><br><span class="line"><span class="comment">// 这里用一个新的对象替换了&#123;count: 0&#125;，因此&#123;count: 0&#125;将会丢失响应性</span></span><br><span class="line">state = <span class="title function_">reactive</span>(&#123; <span class="attr">count</span>: <span class="number">1</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> state = <span class="title function_">reactive</span>(&#123; <span class="attr">count</span>: <span class="number">0</span> &#125;)</span><br><span class="line"><span class="comment">// n被赋值出来，失去了响应性，n的变化不会影响state</span></span><br><span class="line"><span class="keyword">let</span> n = state.<span class="property">count</span></span><br><span class="line">n++</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>日常经验</title>
    <url>/2022/08/30/%E6%97%A5%E5%B8%B8%E7%BB%8F%E9%AA%8C/</url>
    <content><![CDATA[<p>今天在做写vue3的时候，要给组件的prop设置默认值，碰到一直报错的情况：<br><em>不能将类型“{}”分配给类型“(props: Readonly<Props>) =&gt; KV<unknown>”。 类型“{}”提供的内容与签名“(props: Readonly<Props>): KV<unknown>”不匹配。ts(2322)</em></p>
<span id="more"></span>
<p>代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">interface <span class="title class_">Props</span> &#123;</span><br><span class="line">  <span class="attr">modelValue</span>: <span class="variable constant_">KV</span>;</span><br><span class="line">  items?: <span class="title class_">Item</span>[];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> props = <span class="title function_">withDefaults</span>(defineProps&lt;<span class="title class_">Props</span>&gt;(),&#123;</span><br><span class="line">  <span class="comment">// 🔥 问题就出在这里 ↓ </span></span><br><span class="line">  <span class="attr">modelValue</span>:&#123;&#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>原因：<em><strong>引用型数据作为默认值, 要嵌套一层函数</strong></em>，修改为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> props = <span class="title function_">withDefaults</span>(defineProps&lt;<span class="title class_">Props</span>&gt;(),&#123;</span><br><span class="line">  <span class="attr">modelValue</span>:<span class="function">()=&gt;</span>(&#123;&#125;), <span class="comment">// 函数返回</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>redux</title>
    <url>/2022/08/27/redux/</url>
    <content><![CDATA[<p>A Predictable State Container for JS Apps是Redux官方对于Redux的描述，这句话可以这样翻译“一个专为JS应用设计的可预期的状态容器”，简单来说Redux是一个可预测的状态容器。</p>
<span id="more"></span>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><h4 id="状态（State）"><a href="#状态（State）" class="headerlink" title="状态（State）"></a>状态（State）</h4><p>state直译过来就是状态，使用React这么久了，对于state我们已经是非常的熟悉了。state不过就是一个变量，一个用来记录（组件）状态的变量。组件可以根据不同的状态值切换为不同的显示，比如，用户登录和没登录看到页面应该是不同的，那么用户的登录与否就应该是一个状态。再比如，数据加载与否，显示的界面也应该不同，那么数据本身就是一个状态。换句话说，状态控制了页面的如何显示。</p>
<p>但是需要注意的是，状态并不是React中或其他类似框架中独有的。所有的编程语言，都有状态，所有的编程语言都会根据不同的状态去执行不同的逻辑，这是一定的。所以状态是什么，状态就是一个变量，用以记录程序执行的情况。</p>
<h4 id="容器（Container）"><a href="#容器（Container）" class="headerlink" title="容器（Container）"></a>容器（Container）</h4><p>容器当然是用来装东西的，状态容器即用来存储状态的容器。状态多了，自然需要一个东西来存储，但是容器的功能却不是仅仅能存储状态，它实则是一个状态的管理器，除了存储状态外，它还可以用来对state进行查询、修改等所有操作。（编程语言中容器几乎都是这个意思，其作用无非就是对某个东西进行增删改查）</p>
<h4 id="可预测（Predictable）"><a href="#可预测（Predictable）" class="headerlink" title="可预测（Predictable）"></a>可预测（Predictable）</h4><p>可预测指我们在对state进行各种操作时，其结果是一定的。即以相同的顺序对state执行相同的操作会得到相同的结果。简单来说，Redux中对状态所有的操作都封装到了容器内部，外部只能通过调用容器提供的方法来操作state，而不能直接修改state。这就意味着外部对state的操作都被容器所限制，对state的操作都在容器的掌控之中，也就是可预测。</p>
<p>总的来说，<strong>Redux是一个稳定、安全的状态管理器</strong>。<br><img src="./redux/redux.png"></p>
<h4 id="redux与reducer、context"><a href="#redux与reducer、context" class="headerlink" title="redux与reducer、context"></a>redux与reducer、context</h4><p>Redux可以理解为是<em>reducer和context的结合体</em>，使用Redux即可管理复杂的state，又可以在不同的组件间方便的共享传递state。当然，Redux主要使用场景依然是大型应用，大型应用中状态比较复杂，如果只是使用reducer和context，开发起来并不是那么的便利，此时一个有一个功能强大的状态管理器就变得尤为的重要</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><blockquote>
<p>1.引入redux核心包<br>  2.创建reducer整合函数<br>  3.通过reducer对象创建store<br>  4.对store中的state进行订阅<br>  5.通过dispatch派发state的操作指令</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Redux</span>.<span class="title function_">createStore</span>(reducer, [preloadedState], [enhancer])</span><br></pre></td></tr></table></figure>
<p>createStore用来创建一个Redux中的容器对象，它需要三个参数：reducer、preloadedState、enhancer。</p>
<p>reducer是一个函数，是state操作的整合函数，每次修改state时都会触发该函数，它的返回值会成为新的state。</p>
<p>preloadedState就是state的初始值，可以在这里指定也可以在reducer中指定。</p>
<p>enhancer增强函数用来对state的功能进行扩展。<br>三个参数中，只有reducer是必须的，来看一个Reducer的示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">countReducer</span> = (<span class="params">state = &#123;count:<span class="number">0</span>&#125;, action</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">switch</span> (action.<span class="property">type</span>)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;ADD&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="attr">count</span>:state.<span class="property">count</span>+<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;SUB&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="attr">count</span>:state.<span class="property">count</span>-<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="attr">default</span>:</span><br><span class="line">            <span class="keyword">return</span> state</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>reducer用来整合关于state的所有操作，容器修改state时会自动调用该函数，函数调用时会接收到两个参数：<em>state</em>和<em>action</em>，state表示当前的state，可以通过该state来计算新的state。<code> state = &#123;count:0&#125;</code>这是在指定state的默认值，如果不指定，第一次调用时state的值会是undefined。也可以将该值指定为createStore()的第二个参数。action是一个普通对象，用来存储操作信息。</p>
<p>将reducer传递进createStore后，我们会得到一个store对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="title class_">Redux</span>.<span class="title function_">createStore</span>(countReducer);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>store对象创建后，对state的所有操作都需要通过它来进行：<br>读取state：store.getState()<br>修改state：store.dispatch({type:’ADD’})</p>
</blockquote>
<p>dipatch用来触发state的操作，可以将其理解为是想reducer发送任务的工具。它需要一个对象作为参数，这个对象将会成为reducer的第二个参数action，需要将操作信息设置到对象中传递给reducer。action中最重要的属性是type，type用来识别对state的不同的操作，上例中’ADD’表示增加操作，’SUB’表示减少的操作。</p>
<p>除了这些方法外，store还拥有一个subscribe方法，这个方法用来订阅state变化的信息。该方法需要一个回调函数作为参数，当store中存储的state发生变化时，回调函数会自动调用，我们可以在回调函数中定义state发生变化时所要触发的操作：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">store.<span class="title function_">subscribe</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// store中state发生变化时触发</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><blockquote>
<p>1.如果state过于复杂，将会非常难以维护<br>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以通过对state分组来解决这个问题，创建多个reducer，然后将其合并为一个<br>2.state每次操作时，都需要对state进行复制，然后再去修改<br>3.case后边的常量维护起来会比较麻烦</p>
</blockquote>
<h4 id="合并reducer"><a href="#合并reducer" class="headerlink" title="合并reducer"></a>合并reducer</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">stuReducer</span> = (<span class="params">state = &#123;</span></span><br><span class="line"><span class="params">    name: <span class="string">&#x27;孙悟空&#x27;</span>,</span></span><br><span class="line"><span class="params">    age: <span class="number">18</span>,</span></span><br><span class="line"><span class="params">    gender: <span class="string">&#x27;男&#x27;</span>,</span></span><br><span class="line"><span class="params">    address: <span class="string">&#x27;花果山&#x27;</span></span></span><br><span class="line"><span class="params">&#125;, action</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">switch</span> (action.<span class="property">type</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;SET_NAME&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                ...state,</span><br><span class="line">                <span class="attr">name</span>: action.<span class="property">payload</span></span><br><span class="line">            &#125;;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;SET_AGE&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                ...state,</span><br><span class="line">                <span class="attr">age</span>: action.<span class="property">payload</span></span><br><span class="line">            &#125;;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;SET_ADDRESS&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                ...state,</span><br><span class="line">                <span class="attr">address</span>: action.<span class="property">payload</span></span><br><span class="line">            &#125;;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;SET_GENDER&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                ...state,</span><br><span class="line">                <span class="attr">gender</span>: action.<span class="property">payload</span></span><br><span class="line">            &#125;;</span><br><span class="line">        <span class="keyword">default</span> :</span><br><span class="line">            <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">schoolReducer</span> = (<span class="params">state = &#123;</span></span><br><span class="line"><span class="params">    name: <span class="string">&#x27;花果山一小&#x27;</span>,</span></span><br><span class="line"><span class="params">    address: <span class="string">&#x27;花果山大街1号&#x27;</span></span></span><br><span class="line"><span class="params">&#125;, action</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">switch</span> (action.<span class="property">type</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;SET_SCHOOL_NAME&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                ...state,</span><br><span class="line">                <span class="attr">name</span>: action.<span class="property">payload</span></span><br><span class="line">            &#125;;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;SET_SCHOOL_ADDRESS&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                ...state,</span><br><span class="line">                <span class="attr">address</span>: action.<span class="property">payload</span></span><br><span class="line">            &#125;;</span><br><span class="line">        <span class="keyword">default</span> :</span><br><span class="line">            <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>修改后reducer被拆分为了stuReducer和schoolReducer，拆分后在编写每个reducer时，只需要考虑当前的state数据，不再需要对无关的数据进行复制等操作，简化了reducer的编写。于此同时将不同的功能编写到了不同的reducer中，降低了代码间的耦合，方便对代码进行维护。</p>
<p>拆分后，还需要使用Redux为我们提供的函数<strong>combineReducer</strong>将多个reducer进行合并，合并后才能传递进createStore来创建store。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> reducer = <span class="title function_">combineReducers</span>(&#123;</span><br><span class="line">    <span class="attr">stu</span>:stuReducer,</span><br><span class="line">    <span class="attr">school</span>:schoolReducer</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="title function_">createStore</span>(reducer);</span><br></pre></td></tr></table></figure>
<p>combineReducer需要一个对象作为参数，对象的属性名可以根据需要指定，比如我们有两种数据stu和school，属性名就命名为stu和school，stu指向stuReducer，school指向schoolReducer。读取数据时，直接通过state.stu读取学生数据，通过state.school读取学校数据。</p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>2022年终总结</title>
    <url>/2022/12/31/2022%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p><a name="r172O"></a></p>
<h2 id="年度回顾"><a href="#年度回顾" class="headerlink" title="年度回顾"></a>年度回顾</h2><p>最近看掘金里面，挺多人都写了年终总结，想着自己也写一份，结果拖着拖着就拖到31号了…说实话，今年是变化极大的一年，无论是我，还是这个社会。经济下行，整个互联网都进入了寒冬，看脉脉上时不时都有裁员的消息，不少应届都有被裁的，现在想来我也是运气够好，没有碰到。21年没有写年终总结，那就把这篇当成毕业后的总结吧。</p>
<span id="more"></span>
<p><a name="Pb3No"></a></p>
<h2 id="关键词：成长"><a href="#关键词：成长" class="headerlink" title="关键词：成长"></a>关键词：成长</h2><blockquote>
<p>工作一年半，要说用一个词来总结的话，我第一个想起来的词就是成长。</p>
</blockquote>
<p>工作一年半，要说用一个词来总结的话，我第一个想起来的词就是成长。不管是在工作，还是生活上都有了挺多的成长。<br><a name="FamDx"></a></p>
<h2 id="1-工作成长"><a href="#1-工作成长" class="headerlink" title="1.工作成长"></a>1.工作成长</h2><p>工作上的成长挺明显的，现在回看我刚毕业的那会，技术简直是惨不忍睹，连vue的一些基础属性用的都不是很熟…菜的离谱了属于是，感觉要不是公司缺人面试都过不了。<br />幸好，经过一年半的工作和学习，成长的挺明显的。技术方面，21年的时候由于项目的局限，主要在学习使用vue2，感觉局限比较大，没有机会去尝试新技术。还好在今年分到新组之后，开始尝试了vue3、ts、vite，也在一个小项目里面使用了react，对自己的技术提升比较大。回看这一年半，可以自信地说没有浪费时间。<br />工作方面，有了几个独立完成的项目，也担任过项目负责人(虽然不知道为啥都是紧急项目…不过总算有了点能放在简历上的经历。<br><a name="LYArv"></a></p>
<h2 id="2-生活成长"><a href="#2-生活成长" class="headerlink" title="2.生活成长"></a>2.生活成长</h2><p>在刚毕业那会儿，我生活技能为0，啥也不懂，找房子都不知道怎么整。现在毕业一年半，中间经历了一次搬家，我的生活技能也练起来了。在22年下半年，我开始学习做菜(感谢b同学送的锅，强迫我走上炸厨房的道路)，还记得第一道菜是西红柿炒鸡蛋，结果因为加多了水做成了西红柿鸡蛋汤，hhhhhh。后来做的多了，跟着菜谱（下厨房yyds）一道道做下来，已经会做好多菜了。虽然有一些还是得看着菜谱，但总算摆脱了”厨房小白“，走出了”新手村“，成就感还是挺大的，以后可以说自己一个人也饿不死了hhhhhh<br><a name="NAApW"></a></p>
<h2 id="End：总结与期待"><a href="#End：总结与期待" class="headerlink" title="End：总结与期待"></a>End：总结与期待</h2><p>删删改改，总算勉强写完了，自从高中毕业之后除了写论文就没写过这么多字的文章，看来写作能力还是得多练练。2022年是我第一个完整的工作年，想想去年7月份刚毕业的时候，好像也没过去多久，结果就已经过去一年半了，时间啊真的过的太快了。最近看到的负能量比较多，希望23年能慢慢变好，家人朋友都能够健健康康。<br />2023年我的希望：</p>
<ul>
<li><input disabled="" type="checkbox"> 多写博客，学typescript、react</li>
<li><input disabled="" type="checkbox"> github保持活跃</li>
<li><input disabled="" type="checkbox"> 可能的话买个相机，学学摄影</li>
<li><input disabled="" type="checkbox"> 找个对象吧</li>
</ul>
<p> <br />zxy           <br />2022/12/31 22:13</p>
]]></content>
      <categories>
        <category>年终总结</category>
      </categories>
      <tags>
        <tag>年终总结</tag>
      </tags>
  </entry>
  <entry>
    <title>javascript笔记</title>
    <url>/2023/03/03/javascript%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="async与defer"><a href="#async与defer" class="headerlink" title="async与defer"></a>async与defer</h3><p>async：可选。表示应该立即开始下载脚本，但不能阻止其他页面动作，比如下载资源或等待其他脚本加载。只对外部脚本文件有效。</p>
<p>defer：可选。表示脚本可以延迟到文档完全被解析和显示之后再执行。只对外部脚本文件有效。在IE7及更早的版本中，对行内脚本也可以指定这个属性。</p>
<blockquote>
<p>当浏览器碰到 script 脚本的时候：<br><code>1 &lt;script src=&quot;script.js&quot;&gt;&lt;/script&gt;</code><br> 没有 defer 或 async，浏览器会立即加载并执行指定的脚本，“立即”指的是在渲染该 script 标签之下的文档元素之前，也就是说不等待后续载入的文档元素，读到就加载并执行。<br> 2 <code>&lt;script async src=&quot;script.js&quot;&gt;&lt;/script&gt;</code><br> 有 async，加载和渲染后续文档元素的过程将和 script.js 的加载与执行并行进行（异步）。<br> 3 <code>&lt;script defer src=&quot;myscript.js&quot;&gt;&lt;/script&gt;</code><br>  有 defer，加载后续文档元素的过程将和 script.js 的加载并行进行（异步），但是 script.js 的执行要在所有元素解析完成之后，DOMContentLoaded 事件触发之前完成。</p>
</blockquote>
<p><img src="../images/defer_async.jpg"><br>蓝色线代表网络读取，红色线代表执行时间，这俩都是针对脚本的；绿色线代表 HTML 解析。</p>
<h3 id="let与var–块作用域与函数作用域"><a href="#let与var–块作用域与函数作用域" class="headerlink" title="let与var–块作用域与函数作用域"></a>let与var–块作用域与函数作用域</h3><p>let与var的作用差不多，最明显的区别是：<code>let声明的范围是块作用域，var声明的范围是函数作用域</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">&#x27;aa&#x27;</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(name); <span class="comment">// aa</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name); <span class="comment">// aa</span></span><br><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> age = <span class="number">26</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(age); <span class="comment">// 26</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(age) <span class="comment">// 未定义</span></span><br></pre></td></tr></table></figure>
<p>结合代码来看，age报错了是因为作用域仅限于<code>块</code>，即<code>&#123;&#125;</code>之间，而name没有报错是因为作用域是整个函数内。如果下面这种情况</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">&#x27;aa&#x27;</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(name); <span class="comment">// aa</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name) <span class="comment">// 未定义，因为name作用域只在test函数内</span></span><br></pre></td></tr></table></figure>
<p>要清楚了解块作用域与函数作用域的区别，不能觉得var定义的变量在哪里都可以使用</p>
<h3 id="变量、缓存与作用域"><a href="#变量、缓存与作用域" class="headerlink" title="变量、缓存与作用域"></a>变量、缓存与作用域</h3><p>ECMAScript变量可以包含两种不同类型的数据：原始值和引用值。<span style="font-weight: bold;">原始值（primitive value）就是最简单的数据，引用值（reference value）则是由多个值构成的对象。</span></p>
<p>6种原始值：<code>Undefined、Null、Boolean、Number、String和Symbol</code><br>原始值不能有属性，尽管尝试给原始值添加属性不会报错</p>
<blockquote>
<p>注意，原始类型的初始化可以只使用原始字面量形式。如果使用的是new关键字，则JavaScript会创建一个<strong>Object</strong>类型的实例，但其行为类似原始值。下面来看看这两种初始化方式的差异：</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name1 = <span class="string">&quot;Nicholas&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> name2 = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Matt&quot;</span>);</span><br><span class="line">name1.<span class="property">age</span> = <span class="number">27</span>;</span><br><span class="line">name2.<span class="property">age</span> = <span class="number">26</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name1.<span class="property">age</span>);     <span class="comment">// undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name2.<span class="property">age</span>);     <span class="comment">// 26</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> name1); <span class="comment">// string</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> name2); <span class="comment">// object</span></span><br></pre></td></tr></table></figure>

<p>ECMAScript中所有函数的参数都是按值传递的。这意味着函数外的值会被复制到函数内部的参数中，就像从一个变量复制到另一个变量一样。如果是原始值，那么就跟原始值变量的复制一样，如果是引用值，那么就跟引用值变量的复制一样。</p>
<p><strong>typeof可以判断原始值，对引用值不好判断</strong>。即可以拿来判断一个变量是否为字符串、数值、布尔值或undefined，当<em>值是对象或null，那么typeof返回”object”</em><br>判断引用值： <strong>instanceof</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">用法：result= variableinstanceof constructor</span><br><span class="line"></span><br><span class="line">  console.log(person instanceof Object);   // 变量person是Object吗？</span><br><span class="line">  console.log(colors instanceof Array);    // 变量colors是Array吗？</span><br><span class="line">  console.log(pattern instanceof RegExp); // 变量pattern是RegExp吗？</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么0.1+0.2!=0.3</title>
    <url>/2023/03/08/%E4%B8%BA%E4%BB%80%E4%B9%880-1-0-2-0-3/</url>
    <content><![CDATA[<p>在开发过程遇到一个很奇怪的问题：类似</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = num1.<span class="title function_">toFixed</span>(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">const</span> b = num2.<span class="title function_">toFixed</span>(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">const</span> c = a + b <span class="comment">// 某些时候c会变成x.xxxxxxxxxx</span></span><br></pre></td></tr></table></figure>
<p>明明是两个两位小数相加，为什么会变成一个这么多位数的小数？<br>在网上查了类似的现象，就发现了这个问题： 为什么<code>0.1 + 0.2 != 0.3</code>?</p>
<p>要弄清楚这个问题，首先要知道javascript是怎么保存数字的：</p>
<blockquote>
<p>JavaScript使用Number类型表示数字（整数和浮点数），遵循 IEEE 754 标准 通过64位来表示一个数字</p>
</blockquote>
<p>通过图片具体看一下数字在内存中的表示:<br><img src="../images/js_number.png"></p>
<ul>
<li>第0位：符号位，0表示正数，1表示负数(s)</li>
<li>第1位到第11位：储存指数部分（e）</li>
<li>第12位到第63位：储存小数部分（即有效数字）f<br>所以在0.1+0.2的过程中，并不是简单的0.1+0.2，计算机先是把0.1和0.2转为了二进制：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">0.1</span> -&gt; <span class="number">0.0001100110011001</span>...</span><br><span class="line"><span class="number">0.2</span> -&gt; <span class="number">0.0011001100110011</span>...</span><br></pre></td></tr></table></figure>
可以看到这两个都是无穷小数，所以相加的结果不是0.3，而是<code>0.30000000000000004</code><h4 id="进制转换方法"><a href="#进制转换方法" class="headerlink" title="进制转换方法"></a>进制转换方法</h4><h5 id="十进制整数转换为二进制整数采用”除2取余，逆序排列”法。"><a href="#十进制整数转换为二进制整数采用”除2取余，逆序排列”法。" class="headerlink" title="十进制整数转换为二进制整数采用”除2取余，逆序排列”法。"></a>十进制整数转换为二进制整数采用”除2取余，逆序排列”法。</h5>具体做法是：用2整除十进制整数，可以得到一个商和余数；再用2去除商，又会得到一个商和余数，如此进行，直到商为小于1时为止，然后把先得到的余数作为二进制数的低位有效位，后得到的余数作为二进制数的高位有效位，依次排列起来。<h5 id="十进制小数转换成二进制小数"><a href="#十进制小数转换成二进制小数" class="headerlink" title="十进制小数转换成二进制小数"></a>十进制小数转换成二进制小数</h5>十进制小数转换成二进制小数采用”乘2取整，顺序排列”法。具体做法是：用2乘十进制小数，可以得到积，将积的整数部分取出，再用2乘余下的小数部分，又得到一个积，再将积的整数部分取出，如此进行，直到积中的小数部分为零，此时0或1为二进制的最后一位。或者达到所要求的精度为止。<br>然后把取出的整数部分按顺序排列起来，先取的整数作为二进制小数的高位有效位，后取的整数作为低位有效位。</li>
</ul>
]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>javascript的垃圾回收机制</title>
    <url>/2023/03/12/javascript%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>JavaScript是使用垃圾回收的语言，也就是说执行环境负责在代码执行时管理内存。在C和C++等语言中，跟踪内存使用对开发者来说是个很大的负担，也是很多问题的来源。JavaScript为开发者卸下了这个负担，通过自动内存管理实现内存分配和闲置资源回收。</p>
<p>基本思路很简单：<strong>确定哪个变量不会再使用，然后释放它占用的内存。这个过程是周期性的，即垃圾回收程序每隔一定时间（或者说在代码执行过程中某个预定的收集时间）就会自动运行</strong>。</p>
<p>垃圾回收过程是一个近似且不完美的方案，因为某块内存是否还有用，属于“不可判定的”问题，意味着靠算法是解决不了的。我们以函数中局部变量的正常生命周期为例。函数中的局部变量会在函数执行时存在。此时，栈（或堆）内存会分配空间以保存相应的值。函数在内部使用了变量，然后退出。此时，就不再需要那个局部变量了，它占用的内存可以释放，供后面使用。这种情况下显然不再需要局部变量了，但并不是所有时候都会这么明显。垃圾回收程序必须跟踪记录哪个变量还会使用，以及哪个变量不会再使用，以便回收内存。如何标记未使用的变量也许有不同的实现方式。不过，在浏览器的发展史上，用到过两种主要的标记策略：<strong>标记清理和引用计数</strong></p>
<h4 id="标记清理"><a href="#标记清理" class="headerlink" title="标记清理"></a>标记清理</h4><p>javaScript最常用的垃圾回收策略是<strong>标记清理</strong>。</p>
<blockquote>
<p>垃圾回收程序运行的时候，会<em>标记内存中存储的所有变量</em>（标记方法有很多种,比如，当变量进入上下文时，反转某一位；或者可以维护“在上下文中”和“不在上下文中”两个变量列表，可以把变量从一个列表转移到另一个列表）。<br>然后，它会将所有在上下文中的变量，以及被在上下文中的变量引用的变量的标记去掉。在此之后再被加上标记的变量就是待删除的了，原因是任何在上下文中的变量都访问不到它们了。随后垃圾回收程序做一次内存清理，销毁带标记的所有值并收回它们的内存。</p>
</blockquote>
<h4 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h4><p>引用计数没那么常用，思路是：</p>
<blockquote>
<p>对每个值都<em>记录它被引用的次数</em>。声明变量并给它赋一个引用值时，这个值的引用数为1。如果同一个值又被赋给另一个变量，那么引用数加1。类似地，如果保存对该值引用的变量被其他值给覆盖了，那么引用数减1。当一个值的引用数为0时，就说明没办法再访问到这个值了，因此可以安全地收回其内存了。垃圾回收程序下次运行的时候就会释放引用数为0的值的内存。</p>
</blockquote>
<p>但是，引用计数有个问题：<strong>循环引用</strong>，就是对象A有一个指针指向B，而B也引用A的情况：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// objectA和objectB通过各自的属性相互引用，意味着它们的引用数都是2，永远不会变成0</span></span><br><span class="line"><span class="comment">// 如果使用引用计数，这两个对象在函数结束后也不会被回收，内存不会被释放</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">problem</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> objectA = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">let</span> objectB = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    objectA.<span class="property">someOtherObject</span> = objectB;</span><br><span class="line">    objectB.<span class="property">anotherObject</span> = objectA;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
</search>
