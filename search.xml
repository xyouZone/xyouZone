<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>React</title>
    <url>/2022/08/23/React/</url>
    <content><![CDATA[<h2 id="state"><a href="#state" class="headerlink" title="state"></a>state</h2><p>在React中，当组件渲染完毕后，再修改组件中的变量，不会使组件重新渲染，要使得组件可以收到变量的影响，必须在变量修改后对组件进行重新渲染，这里我们就需要一个特殊变量，当这个变量被修改时，组件会重新自动渲染。</p>
<span id="more"></span>

<p>state相当于个变量，只是这个变量在react中进行了注册，React会监控这个变量的变化，当state发生变化时，会自动触发组件的重新渲染，使得我们的修改可以在页面中呈现出来。</p>
<p>在函数组件中，偶们需要通过钩子函数，获取state</p>
<p>使用钩子useState()来创建state<br><code>import &#123; useState &#125; from &quot;react&quot;</code></p>
<p>它需要一个值作为参数，这个值就是state的初始值<br>  该函数会返回一个数组</p>
<ul>
<li>数组中第一个元素，是初始值<br>  初始值只用来显示数据，直接修改不会触发组件的重新渲染</li>
<li>第二个元素，是一个函数，通常命名为serXXX<br>  这个函数用来修改state，调用其修改state后会触发组件的重新渲染，并且使用函数中的值作为新的state值。</li>
</ul>
<h3 id="state注意事项"><a href="#state注意事项" class="headerlink" title="state注意事项"></a>state注意事项</h3><p>1、只有state值发生变化时，组件才会重新渲染。<br>2、当state的值是一个对象时，修改时是新的对象去替换旧的对象，意味着类似下面这种方式是不会重新渲染的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> [obj, setObj] = <span class="title function_">useState</span>(&#123;<span class="attr">name</span>: <span class="string">&#x27;aa&#x27;</span>&#125;);</span><br><span class="line">obj.<span class="property">name</span> = <span class="string">&#x27;bb&#x27;</span>;</span><br><span class="line"><span class="title function_">setObj</span>(obj);</span><br></pre></td></tr></table></figure>
<p>正确的修改方法：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">setObj</span>(&#123;...obj,<span class="attr">name</span>:<span class="string">&#x27;bb&#x27;</span>&#125;)</span><br></pre></td></tr></table></figure>
<p>3、通过setState去修改state时，并不代表修改当前的state,它修改的是<strong>组件下一次渲染时state值</strong>。<br>4、setState()会触发组件的重新渲染，它是<strong>异步</strong>的。所以当调用setState()需要调用旧state的值时，一定要注意有可能会出现计算错误的情况。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">setCounter</span>(counter + <span class="number">1</span>);  <span class="comment">// 预期 1 2 3，但如果一秒内点击多次，可能第三次拿到的counter值还是1，出现错误。</span></span><br></pre></td></tr></table></figure>
<p>为了避免这种情况，可以通过为setState()传递回调函数的形式在修改state。<strong>setState()中回调函数的返回值将会成为新的state值，回调函数执行时，React会将最新的state值作为参数传递</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">setCounter</span>(<span class="function"><span class="params">prevCounter</span> =&gt;</span> prevCounter + <span class="number">1</span>);</span><br></pre></td></tr></table></figure>

<h2 id="DOM对象和useRef"><a href="#DOM对象和useRef" class="headerlink" title="DOM对象和useRef()"></a>DOM对象和useRef()</h2><p>获取原生的DOM对象</p>
<ul>
<li>可以使用传统的document来对DOM进行操作</li>
<li>可以从React处获取DOM对象<br>步骤：<br>1、创建一个存储DOM对象的容器<br>使用useRef()钩子函数<br>钩子函数注意事项：<br>①React中的钩子函数只能用于函数组件或自定义钩子<br>②钩子函数只能在函数组件中调用<br>2、将容器设置为想要获取DOM对象元素的ref属性，React会自动将当前元素的DOM对象，设置为容器current属性<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> h1Ref = <span class="title function_">useRef</span>(); <span class="comment">// h1Ref: &#123;current:&lt;h1&gt;&lt;/h1&gt;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">ref</span>=<span class="string">&#123;h1Ref&#125;</span>&gt;</span>....<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
useRef()返回的就是一个普通的JS对象：<code>&#123;current:undefined&#125;</code>,所以我们直接创建一个js对象，也可以代替useRef(),区别：我们创建的对象，组件每次重新渲染都会重新创建一个新对象，useRef()创建的对象，可以确保每次渲染获取到的都是同一个对象。因此，当你需要一个对象不会因为组件的重新渲染而改变时，使用useRef()。</li>
</ul>
<h2 id="类组件"><a href="#类组件" class="headerlink" title="类组件"></a>类组件</h2><ul>
<li>类组件的props是存储到类的实例对象中，可以直接通过实例对象访问<code>this.props</code></li>
<li>类组件中state统一存储到了实例对象的state属性中，可以通过<em>this.state</em>访问，通过<em>this.setState</em>对其进行修改。当我们通过this.setState()修改state时，React只会修改设置了的值，但是仅限于<em>直接</em>存储于state中的属性，类似对象这种属性相当于设置了一个新的对象。</li>
<li>函数组件中，响应函数直接以函数的形式定义在组件中，但是在类组件中，响应函数是以类的方法来定义</li>
<li>类组件中获取DOM对象，使用React提供的createRef<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> divRef = <span class="title class_">React</span>.<span class="title function_">createRef</span>();</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="portal"><a href="#portal" class="headerlink" title="portal"></a>portal</h2><ul>
<li>组件默认会作为父组件的后代渲染到页面中，但是有些情况下，这种方式会带来一些问题。（子组件层级再高也不会超过父组件）</li>
<li>通过portal可以将组件渲染到页面的指定位置</li>
<li>使用方法：<br> 1、在index.html添加一个新的元素<br> 2、修改组件的渲染方式<pre><code>- 通过ReactDOM.createPortal()作为返回值创建元素。
- 参数：1、jsx(修改前return后的代码)；2、目标位置；
</code></pre>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.html</span></span><br><span class="line">&lt;div id=<span class="string">&quot;demo&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// backdrop.js</span></span><br><span class="line"><span class="keyword">const</span> backdropRoot = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;demo&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">Backdrop</span> = (<span class="params">props</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">ReactDOM</span>.<span class="title function_">createPortal</span>(<span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">   xxxxxx</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>,backdropRoot);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="Fragment"><a href="#Fragment" class="headerlink" title="Fragment"></a>Fragment</h2><p>React.Fragment是一个专门用来作为父容器的组件，它只会将它里面的子元素直接返回，不会创建任何多余的元素。当我们希望有一个父容器，但同时不希望父容器在网页中产生多余的结构时，可以使用。</p>
<h2 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h2><p>Context相当于一个公共的存储空间，我们可以将多个组件中都需要访问的数据统一存储到一个Context中,这样无需通过props逐层传递，即可使组件访问到这些数据通过React.createContext()创建context</p>
<p>使用方法一：</p>
<ul>
<li>1、引入context</li>
<li>2、使用 <strong>Xxx.Consumer</strong> 组件来创建元素<br>Consumer 的标签体需要一个回调函数<br>它会将context设置为回调函数的参数，通过参数就可以访问到context中存储的数据<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// testContext.js</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">TestContext</span> = <span class="title class_">React</span>.<span class="title function_">createContext</span>(&#123;</span><br><span class="line">    <span class="attr">content</span>: <span class="string">&#x27;这是公共的数据&#x27;</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title class_">TestContext</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A.js</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">TestContext</span> <span class="keyword">from</span> <span class="string">&quot;../store/testContext&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">A</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">TestContext.Consumer</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            &#123;(ctx)=&gt;&#123;</span></span><br><span class="line"><span class="language-xml">               return <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">                   &#123;ctx.name&#125; - &#123;ctx.age&#125;</span></span><br><span class="line"><span class="language-xml">               <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            &#125;&#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">TestContext.Consumer</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
使用方法二：</li>
<li>1.导入Context</li>
<li>2.使用钩子函数useContext()获取到context，<em>useContext() 需要一个Context作为参数</em>，它会将Context中数据获取并作为返回值返回</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// B.js</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">B</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用钩子函数获取Context</span></span><br><span class="line">    <span class="keyword">const</span> ctx = <span class="title function_">useContext</span>(<span class="title class_">TestContext</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">        <span class="language-xml"><span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="language-xml">            &#123;ctx.name&#125; -- &#123;ctx.age&#125;</span></span><br><span class="line"><span class="language-xml">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">    );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Xxx.Provider表示数据的<strong>生产者</strong>，可以使用它来指定Context中的数据,通过value来指定Context中存储的数据，这样一来，在该组件的<strong>所有的子组件</strong>中都可以通过Context来访问它所指定数据</p>
<p>当我们通过Context访问数据时，他会读取离他<strong>最近</strong>的Provider中的数据，如果没有Provider，则读取Context中的默认数据。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&lt;A /&gt; <span class="comment">// A没有Provider,获取content为testContext.js定义的&#x27;这是公共的数据&#x27;</span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">TestContext.Provider</span> <span class="attr">value</span>=<span class="string">&#123;&#123;content:</span> &#x27;<span class="attr">第一层数据</span>&#x27;&#125;&#125; &gt;</span></span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;<span class="name">TestContext.Provider</span> <span class="attr">value</span>=<span class="string">&#123;&#123;content:</span> &#x27;<span class="attr">第二层数据</span>&#x27;&#125;&#125; &gt;</span></span></span><br><span class="line"><span class="language-xml">    <span class="tag">&lt;<span class="name">B</span>/&gt;</span> // B里面获取content为&quot;第二层数据&quot;</span></span><br><span class="line"><span class="language-xml">  <span class="tag">&lt;/<span class="name">TestContext.Provider</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"><span class="tag">&lt;/<span class="name">TestContext.Provider</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h2 id="setState的执行过程"><a href="#setState的执行过程" class="headerlink" title="setState的执行过程"></a>setState的执行过程</h2><p>setState()实际调用dispatchSetDate(),会检查组件当前处于哪个阶段。<br>实际组件存在两个阶段：<strong>渲染阶段</strong>和<strong>非渲染阶段</strong><br>渲染阶段：元素还没渲染到页面中，函数组件的函数体会执行一遍；<strong>此时setState不会检查state值是否相同</strong><br>非渲染阶段：元素已经渲染到页面中，<strong>此时setState会检查state值是否相同</strong>。</p>
<ul>
<li>如果值不相同，则会对组件进行重新渲染。</li>
<li>如果值相同，不对组件进行重新渲染（在一些情况下会继续执行当前组件的渲染，但是这个渲染不会触发其子组件的渲染，这次渲染不会产生实际的效果，这种情况通常发生在值第一次相同时）。</li>
</ul>
<h2 id="useEffect"><a href="#useEffect" class="headerlink" title="useEffect"></a>useEffect</h2><p><code>useEffect()</code>是一个钩子函数，需要一个函数作为参数，这个作为参数的函数，将会在组件渲染完毕后执行，在开发中，可以将那些会产生副作用的代码编写到useEffect的回调函数中，这样就可以避免这些代码影响到组件的渲染</p>
<ul>
<li>默认情况下，useEffect()中的函数，会在组件渲染完成后调用，并且是每次渲染完成后都会调用。在useEffect()可以传递一个第二个参数，第二个参数是一个数组，在数组中可以指定Effect的依赖项，指定后<strong>只有当依赖发生变化时，Effect才会被触发</strong>。</li>
<li>通常会将Effect中使用的所有的局部变量都设置为依赖项，这样一来可以确保这些值发生变化时，会触发Effect的执行。像setState()是由钩子函数useState()生成的，useState()会确保组件的每次渲染都会获取到相同setState()对象(即setCount()这种函数是固定不变的)，所以setState()方法可以不设置到依赖中。</li>
<li>如果依赖项设置了一个空数组，则意味Effect只会在组件初始化时触发一次。</li>
<li>在Effect的回调函数中，可以指定一个函数作为返回值，这个函数可以称其为清理函数，它会在<span style="color:red;"><em>下次Effect执行前调用</em></span>，<strong>可以在这个函数中，做一些工作来清除上次Effect执行所带来的的影响</strong><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">useEffect</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">  <span class="keyword">const</span> timer = <span class="built_in">setTimeout</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Effect触发了！&#x27;</span>);</span><br><span class="line">      props.<span class="title function_">onFilter</span>(keyword);</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="function">() =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">clearTimeout</span>(timer); <span class="comment">// 清除上一次effect的定时器</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">&#125;, [keyword]);</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>V8引擎的工作原理</title>
    <url>/2022/08/23/V8%E5%BC%95%E6%93%8E%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<p>我们知道了V8的演进历史，知道目前V8的核心部分为：<br /><strong>解析器（Parser）<br />解释器（Ignition）<br />优化编译器（TurboFan）</strong><br />1.V8脚本引擎的由来。<br />2. V8脚本引擎的演进。<br />3. V8核心模块：解析器，解释器，优化编译器。<br><a name="qJLPh"></a></p>
<span id="more"></span>
<h3 id="V8是怎么执行JavaScript代码的？"><a href="#V8是怎么执行JavaScript代码的？" class="headerlink" title="V8是怎么执行JavaScript代码的？"></a>V8是怎么执行JavaScript代码的？</h3><p>当V8执行JavaScript源码时，首先解析器会把源码解析为<strong>抽象语法树</strong>（Abstract Syntax Tree），解释器再将AST翻译为字节码，一遍解释一遍执行。<br />在此过程中，解释器会记特定代码片段的运行次数，如果代码运行次数超过某个阈值，那么该段代码就被标记为热代码，并将运行信息反馈给优化编译器。<br />优化编译器根据反馈信息，优化并编译字节码，最终生成优化后的机器码，当该段代码再次执行时，不用再次解释，提升了效率。<br />这种在运行时编译代码的技术称之为JIT(即时编译)，通过JIT可以极大提升JavaScript代码的执行性能。<br><a name="vt4Vf"></a></p>
<h3 id="简单介绍每个的作用"><a href="#简单介绍每个的作用" class="headerlink" title="简单介绍每个的作用"></a>简单介绍每个的作用</h3><ul>
<li>解析器将 JavaScript 源码解析为 AST，解析过程分为词法分析和语法分析，V8 通过预解析提升解析效率；</li>
<li>解释器 Ignition 根据 AST 生成字节码并执行。这个过程中会收集执行反馈信息，交给 TurboFan 进行优化编译；</li>
<li>TurboFan 根据 Ignition 收集的反馈信息，将字节码编译为优化后的机器码，后续 Ignition 用优化机器码代替字节码执行，进而提升性能。<br><a name="sOObc"></a><h4 id="解析器（Parser）如何把源码转成AST？"><a href="#解析器（Parser）如何把源码转成AST？" class="headerlink" title="解析器（Parser）如何把源码转成AST？"></a>解析器（Parser）如何把源码转成AST？</h4>让V8执行我们的编写的源码，就要将源码装换成V8能理解的格式。V8会先把源码解析为抽象语法树（AST），这是用来表示源码的树形结构的对象，这个过程称之为<strong>解析（Parsing）</strong>。<br />解析和编译过程的性能非常重要，V8只有等编译完成后才能运行代码。解析过程如下图：</li>
</ul>
<p><img src="/images/v801.png"><br />分为两部分：</p>
<ol>
<li>词法分析：将字符流转换为tokens，字符流就是我们编写的一行行代码，token是指语法上不能再分割的最小单位（可能是单个字符，也可能是字符串）图中的Scanner就是V8的<strong>词法分析器</strong>。</li>
<li>语法分析：根据语法规则，将tokens组成一个有嵌套层级的AST，在此过程，如果源码不符合语法规范，解析过程就会终止，并抛出语法错误。图中的Parser和Pre-Parse都是V8的<strong>语法分析器</strong>。<br><a name="qchFZ"></a><h5 id="词法分析"><a href="#词法分析" class="headerlink" title="词法分析"></a>词法分析</h5>在V8中，Scanner负责接收Unicode字符流，并将其解析为tokens，提供给解析器使用。比如 var a = 1;，这行代码经过词法分析后的tokens是这样：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;type&quot;</span>: <span class="string">&quot;Keyword&quot;</span>,</span><br><span class="line">        <span class="string">&quot;value&quot;</span>: <span class="string">&quot;var&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;type&quot;</span>: <span class="string">&quot;Identifier&quot;</span>,</span><br><span class="line">        <span class="string">&quot;value&quot;</span>: <span class="string">&quot;a&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;type&quot;</span>: <span class="string">&quot;Punctuator&quot;</span>,</span><br><span class="line">        <span class="string">&quot;value&quot;</span>: <span class="string">&quot;=&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;type&quot;</span>: <span class="string">&quot;Numeric&quot;</span>,</span><br><span class="line">        <span class="string">&quot;value&quot;</span>: <span class="string">&quot;1&quot;</span></span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">&quot;type&quot;</span>: <span class="string">&quot;Punctuator&quot;</span>,</span><br><span class="line">        <span class="string">&quot;value&quot;</span>: <span class="string">&quot;;&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>
包含了五个tokens：</li>
</ol>
<ul>
<li><p>关键字 var</p>
</li>
<li><p>标识符 a</p>
</li>
<li><p>赋值运算符 =</p>
</li>
<li><p>数值 1</p>
</li>
<li><p>分隔符 ；<br><a name="OuGtq"></a></p>
<h5 id="语法分析"><a href="#语法分析" class="headerlink" title="语法分析"></a>语法分析</h5><p>接下来，V8的解析器会通过语法分析，根据tokens生成AST，var a = 1; 这行代码生成的AST的JSON结构如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;type&quot;</span>: <span class="string">&quot;Program&quot;</span>,</span><br><span class="line">  <span class="string">&quot;start&quot;</span>: <span class="number">0</span>,</span><br><span class="line">  <span class="string">&quot;end&quot;</span>: <span class="number">10</span>,</span><br><span class="line">  <span class="string">&quot;body&quot;</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="string">&quot;type&quot;</span>: <span class="string">&quot;VariableDeclaration&quot;</span>,</span><br><span class="line">      <span class="string">&quot;start&quot;</span>: <span class="number">0</span>,</span><br><span class="line">      <span class="string">&quot;end&quot;</span>: <span class="number">10</span>,</span><br><span class="line">      <span class="string">&quot;declarations&quot;</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="string">&quot;type&quot;</span>: <span class="string">&quot;VariableDeclarator&quot;</span>,</span><br><span class="line">          <span class="string">&quot;start&quot;</span>: <span class="number">4</span>,</span><br><span class="line">          <span class="string">&quot;end&quot;</span>: <span class="number">9</span>,</span><br><span class="line">          <span class="string">&quot;id&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;type&quot;</span>: <span class="string">&quot;Identifier&quot;</span>,</span><br><span class="line">            <span class="string">&quot;start&quot;</span>: <span class="number">4</span>,</span><br><span class="line">            <span class="string">&quot;end&quot;</span>: <span class="number">5</span>,</span><br><span class="line">            <span class="string">&quot;name&quot;</span>: <span class="string">&quot;a&quot;</span></span><br><span class="line">          &#125;,</span><br><span class="line">          <span class="string">&quot;init&quot;</span>: &#123;</span><br><span class="line">            <span class="string">&quot;type&quot;</span>: <span class="string">&quot;Literal&quot;</span>,</span><br><span class="line">            <span class="string">&quot;start&quot;</span>: <span class="number">8</span>,</span><br><span class="line">            <span class="string">&quot;end&quot;</span>: <span class="number">9</span>,</span><br><span class="line">            <span class="string">&quot;value&quot;</span>: <span class="number">1</span>,</span><br><span class="line">            <span class="string">&quot;raw&quot;</span>: <span class="string">&quot;1&quot;</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      ],</span><br><span class="line">      <span class="string">&quot;kind&quot;</span>: <span class="string">&quot;var&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  <span class="string">&quot;sourceType&quot;</span>: <span class="string">&quot;module&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>对生成AST内容感兴趣的可以在 <a href="https://link.juejin.cn/?target=https://astexplorer.net/">astexplorer.net/</a> 中查看。<br />但是，对于一份JavaScript源码，如果所有的源码在执行前都要解析才能执行，那会面临一下问题。</p>
</li>
<li><p><strong>代码执行时间变长</strong>：一次性解析所有代码，必然会增加代码的运行时间。</p>
</li>
<li><p><strong>消耗更多内存</strong>：解析完的AST，以及根据AST编译后的字节码都会存放在内存中，必然会占用更多内存空间。</p>
</li>
<li><p><strong>占用磁盘空间</strong>：编译后的代码会缓存在磁盘上，占用磁盘空间。</p>
</li>
</ul>
<p>所以，现在主流JavaScript引擎都实现了延迟解析（Lazy Parsing）。<br><a name="KWBQo"></a></p>
<h5 id="延迟解析"><a href="#延迟解析" class="headerlink" title="延迟解析"></a>延迟解析</h5><p>延迟解析的思想：在解析过程中，对于不是立即执行的函数，只进行<strong>预解析（Pre Parser）</strong>,只有当函数调用时，才对函数进行全量解析。<br />进行预解析时，只验证函数语法是否有效，解析函数声明、确定函数作用域。不生成AST，实现预解析的是Pre-Parser解析器。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">foo</span>(<span class="params">a, b</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> res = a + b;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">var</span> c = <span class="number">2</span>;</span><br><span class="line"><span class="title function_">foo</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>由于 Scanner 是按字节流从上往下一行行读取代码的，所以 V8 解析器也是从上往下解析代码。当 V8 解析器遇到函数声明 foo 时，发现它不是立即执行，所以会用 Pre-Parser 解析器对其预解析，过程中只会解析函数声明，不会解析函数内部代码，不会为函数内部代码生成 AST。<br />然后 Ignition 解释器会把 AST 编译为字节码并执行，解释器会按照自上而下的顺序执行代码，先执行 var a = 1;  和 var c = 2; 两个赋值表达式，然后执行函数调用 foo(1, 2) ，这时 Parser 解析器才会继续解析函数内的代码、生成 AST，再交给 Ignition 解释器编译执行。</p>
<blockquote>
<p><a name="Yk77z"></a></p>
</blockquote>
<h4 id="解释器（Ignition）如何将-AST翻译为字节码并执行？"><a href="#解释器（Ignition）如何将-AST翻译为字节码并执行？" class="headerlink" title="解释器（Ignition）如何将 AST翻译为字节码并执行？"></a>解释器（Ignition）如何将 AST翻译为字节码并执行？</h4><p>在V8架构的演进中，<a href="https://juejin.cn/post/7060870761120006157">浅谈V8脚本引擎的工作原理（二.V8脚本引擎的演进）</a>提到的V8为了解决内存占用问题，引入了字节码。如图，通常一个几十KB的文件，转换为机器码可能就是几十兆，这回消耗巨大内存。<br /><img src="/images/v802.png"><br><a name="LciFb"></a></p>
<h5 id="什么是字节码"><a href="#什么是字节码" class="headerlink" title="什么是字节码"></a>什么是字节码</h5><p>V8的字节码是对机器码的抽象，语法与汇编有些类似，我们可以把V8字节码看做一个个指令，这些指令组合到一起实现我们编写的功能，采用和物理CPU相同的计算模型进行设计。JavaScript源码的任何功能都可以等价转换成字节码的组合。字节码生成其实是遍历树的过程，V8定义了几百个字节码，可以在V8解释器头文件中查看到所有字节码<a href="https://link.juejin.cn/?target=https://github.com/v8/v8/blob/master/src/interpreter/bytecodes.h">bytecodes.h</a>。<br />解释器在执行字节码时，主要使用通用寄存器和累加寄存器，函数参数和局部变量都保存在通用寄存器中r0,r1，累加寄存器用于保存中间结果（accumulator register）。<br />举例说明字节码执行流程。 首先定义一个含有三个形参的函数f，函数功能就是对参数进行计算，并返回值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// index.js</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">f</span>(<span class="params">a, b, c</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> d = c - <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">return</span> a + d * b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="title function_">f</span>(<span class="number">5</span>, <span class="number">2</span>, <span class="number">150</span>);</span><br></pre></td></tr></table></figure>
<p>假设我们以实参5、2、150调用函数，则解释器会把函数编译为字节码。<br />可以通过node –print-bytecode index.js 来查看JavaScript文件生成的字节码。(会生成非常多，取了最后一段重要的)</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">$ node --print-bytecode index.<span class="property">js</span></span><br><span class="line">... </span><br><span class="line">[generated bytecode <span class="keyword">for</span> <span class="attr">function</span>: f (<span class="number">0x242cd33a35b9</span> &lt;<span class="title class_">SharedFunctionInfo</span> f&gt;)]</span><br><span class="line"><span class="title class_">Parameter</span> count <span class="number">4</span></span><br><span class="line"><span class="title class_">Register</span> count <span class="number">1</span></span><br><span class="line"><span class="title class_">Frame</span> size <span class="number">8</span></span><br><span class="line">   <span class="number">32</span> S&gt; <span class="number">0x242cd33a3e06</span> @    <span class="number">0</span> : <span class="number">25</span> <span class="number">02</span>             <span class="title class_">Ldar</span> a2</span><br><span class="line">   <span class="number">34</span> E&gt; <span class="number">0x242cd33a3e08</span> @    <span class="number">2</span> : <span class="number">41</span> <span class="number">64</span> <span class="number">00</span>          <span class="title class_">SubSmi</span> [<span class="number">100</span>], [<span class="number">0</span>]</span><br><span class="line">         <span class="number">0x242cd33a3e0b</span> @    <span class="number">5</span> : <span class="number">26</span> fb             <span class="title class_">Star</span> r0</span><br><span class="line">   <span class="number">43</span> S&gt; <span class="number">0x242cd33a3e0d</span> @    <span class="number">7</span> : <span class="number">25</span> <span class="number">03</span>             <span class="title class_">Ldar</span> a1</span><br><span class="line">   <span class="number">56</span> E&gt; <span class="number">0x242cd33a3e0f</span> @    <span class="number">9</span> : <span class="number">36</span> fb <span class="number">02</span>          <span class="title class_">Mul</span> r0, [<span class="number">2</span>]</span><br><span class="line">   <span class="number">52</span> E&gt; <span class="number">0x242cd33a3e12</span> @   <span class="number">12</span> : <span class="number">34</span> <span class="number">04</span> <span class="number">01</span>          <span class="title class_">Add</span> a0, [<span class="number">1</span>]</span><br><span class="line">   <span class="number">60</span> S&gt; <span class="number">0x242cd33a3e15</span> @   <span class="number">15</span> : aa                <span class="title class_">Return</span></span><br><span class="line"><span class="title class_">Constant</span> pool (size = <span class="number">0</span>)</span><br><span class="line"><span class="title class_">Handler</span> <span class="title class_">Table</span> (size = <span class="number">0</span>)</span><br><span class="line"><span class="title class_">Source</span> <span class="title class_">Position</span> <span class="title class_">Table</span> (size = <span class="number">14</span>)</span><br><span class="line"><span class="number">0x242cd33a3e19</span> &lt;<span class="title class_">ByteArray</span>[<span class="number">14</span>]&gt;</span><br></pre></td></tr></table></figure>
<p>当解释器执行代码时，会把参数分别加载到a0、a1、a2寄存器上（图中 accumulator 表示累加寄存器）然后逐行执行字节码。<br /><img src="/images/v803.png"></p>
<ul>
<li>读取形参 c 并做出计算</li>
<li>Ldar a2: Ldar表示将寄存器的值加载到累加器的操作。a2是加载的数值，加载后，accumulator的值为150。</li>
</ul>
<p><img src="/images/v804.png"></p>
<ul>
<li>将计算结果放入累加寄存器中。</li>
<li>SubSmi [100], [0]：SubSmi [100] 表示将累加寄存器的值减少 100，这时 accumulator 的值就变为了 50，[0] 反馈向量 (FeedBack Vector) 的索引，反馈向量记录了函数在执行过程中的一些关键的中间数据。</li>
</ul>
<p><img src="/images/v805.png"></p>
<ul>
<li>将累加寄存器的值放到r0中临时记录 也是变量b的值</li>
<li>Star r0：表示把累加器中的值保存到寄存器 r0 中，这时 r0 的值就变为了 50。</li>
</ul>
<p><img src="/images/v806.png"></p>
<ul>
<li>读取a + d * b语句，先执行d * b</li>
<li>Ldar a1:表示将寄存器a1的值加载到累加寄存器，这时accumulator的值变为2。</li>
</ul>
<p><img src="/images/v807.png"></p>
<ul>
<li>继续执行d * b的第二个动作</li>
<li>Mul r0,[2]：Mul r0 表示将accumulator的值与 r0 寄存器的值相乘，并把结果再次放入累加寄存器，其中 [2] 同样是反馈向量，执行完毕后，accumulator 的值就变为了 100。</li>
</ul>
<p><img src="/images/v808.png"></p>
<ul>
<li>执行a + 100的动作</li>
<li>Add a0, [1]：Add a0 表示将累加寄存器的值与 a0 寄存器的值相加，并将结果再次放入累加寄存器，这时 accumulator 的值就变为了 105。</li>
</ul>
<p><img src="/images/v809.png"></p>
<ul>
<li>Return：表示结束当前函数的执行，并返回累加寄存器中的值，函数执行结果是 105。</li>
</ul>
<p>这是解释器执行字节码的简单过程（中间省略了对AST遍历翻译成的字节码的环节），但依旧需要对字节码转换为机器码，CPU只识别机器码。</p>
<p>看似多了一层字节码的转换感觉效率低了，但相比于机器码，字节码的优势是更方便进行性能优化，最主要是由优化编译器编译热点代码。基于字节码的优化的架构性能远超直接转为机器码的架构性能。<br />前面提到Ignition解释器在执行的过程中，会标记重复执行的热点代码交给TurboFan生成效率更高的机器码，接下来看看TurboFan是如何工作的。<br><a name="QfgVh"></a></p>
<h4 id="优化编译器（TuboFan）的工作原理"><a href="#优化编译器（TuboFan）的工作原理" class="headerlink" title="优化编译器（TuboFan）的工作原理"></a>优化编译器（TuboFan）的工作原理</h4><p>V8在提示JavaScript性能方面做了很多优化工作,其中最主要的有内联和逃逸分析两种算法。<br><a name="iJeML"></a></p>
<h5 id="内敛（inlining）"><a href="#内敛（inlining）" class="headerlink" title="内敛（inlining）"></a>内敛（inlining）</h5><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">three</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">add</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先我们定义了一个求和函数 add ，函数有两个参数 x 和 y，然后定义了函数 three ，并在函数 three 中调用 add 函数。<br />如果不经优化，直接编译该段代码，则会分别生成两个函数的机器码。但为了进一步提升性能，TurboFan优化编译器首先会对以上两个函数进行内联，然后再编译。<br />由于函数 three 内部的行为就是求 1 和 2 的和，所以上面的代码就等价于下面的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">add</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">three</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="title function_">add</span>(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>更进一步，由于函数 three_add_inlined 中 x 和 y 的值都是确定的，所以 three_add_inlined 还可以进一步优化，直接返回结果 3 ：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">three_add_const_folded</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/images/v810.png"><br />通过内联，可以降低复杂度、消除冗余代码、合并常量，并且内联技术通常也是逃逸分析的基础。那什么又是逃逸分析呢？<br><a name="FlH4X"></a></p>
<h5 id="逃逸分析（Escape-Analysis）"><a href="#逃逸分析（Escape-Analysis）" class="headerlink" title="逃逸分析（Escape Analysis）"></a>逃逸分析（Escape Analysis）</h5><p>分析对象的生命周期是否仅限于当前函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Point</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">x, y</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">x</span> = x;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">y</span> = y;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="title function_">distance</span>(<span class="params">that</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">abs</span>(<span class="variable language_">this</span>.<span class="property">x</span> - that.<span class="property">x</span>)</span><br><span class="line">         + <span class="title class_">Math</span>.<span class="title function_">abs</span>(<span class="variable language_">this</span>.<span class="property">y</span> - that.<span class="property">y</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">manhattan</span>(<span class="params">x1, y1, x2, y2</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> a = <span class="keyword">new</span> <span class="title class_">Point</span>(x1, y1);</span><br><span class="line">  <span class="keyword">const</span> b = <span class="keyword">new</span> <span class="title class_">Point</span>(x2, y2);</span><br><span class="line">  <span class="keyword">return</span> a.<span class="title function_">distance</span>(b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们定义了一个 Point  类，用于表示某个点的坐标，类中有个 distance 方法，用来计算两个点之前的曼哈顿距离。<br />然后我们在 manhattan 函数中 new 了两个点， a 和 b ，并计算 a b 的曼哈顿距离。TurboFan 首先会通过内联，将 manhattan 函数转换为下面这样的函数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">manhattan_inlined</span>(<span class="params">x1, y1, x2, y2</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> a = &#123;<span class="attr">x</span>:x1, <span class="attr">y</span>:y1&#125;;</span><br><span class="line">  <span class="keyword">const</span> b = &#123;<span class="attr">x</span>:x2, <span class="attr">y</span>:y2&#125;;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">abs</span>(a.<span class="property">x</span> - b.<span class="property">x</span>)</span><br><span class="line">       + <span class="title class_">Math</span>.<span class="title function_">abs</span>(a.<span class="property">y</span> - b.<span class="property">y</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再接下来就会对 manhattan_inlined 中的对象进行逃逸分析。什么样的对象会被认为是“未逃逸”的呢？主要有以下几个条件：</p>
<ul>
<li>对象在函数内部定义；</li>
<li>对象在作用域函数内部，如：没有被返回、没有传递应用给其他函数等。</li>
</ul>
<p>在 manhattan_inlined 中，变量 a b 都是函数内的普通对象，所以它们都是“未逃逸”对象。那么我们就可以对函数中的对象进行替换，使用标量替换掉对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">manhattan_scalar_eplacement</span>(<span class="params">x1, y1, x2, y2</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> a_x = x1;</span><br><span class="line">  <span class="keyword">var</span> a_y = y1;</span><br><span class="line">  <span class="keyword">var</span> b_x = x2;</span><br><span class="line">  <span class="keyword">var</span> b_y = y2;</span><br><span class="line">  <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">abs</span>(a_x - b_x)</span><br><span class="line">       + <span class="title class_">Math</span>.<span class="title function_">abs</span>(a_y - b_y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样函数内就不再有对象定义，取而代之的是 a_x a_y b_x b_y ，且直接来源于函数参数。<br />这样做的好处是，我们可以直接将变量加载到寄存器上，不再需要从内存中访问对象属性了，提升了执行效率的同时还减少了内存使用。</p>
]]></content>
      <categories>
        <category>浏览器</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>vue3基础</title>
    <url>/2022/08/28/vue3%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h3 id="Vue应用实例"><a href="#Vue应用实例" class="headerlink" title="Vue应用实例"></a>Vue应用实例</h3><p>当使用Vue3脚手架生成项目后，我们可以在main.js中看到这么一段代码：</p>
<span id="more"></span>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createApp &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="title class_">App</span> <span class="keyword">from</span> <span class="string">&#x27;./App.vue&#x27;</span></span><br><span class="line"><span class="keyword">import</span> <span class="string">&#x27;./index.css&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="title function_">createApp</span>(<span class="title class_">App</span>).<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>)</span><br></pre></td></tr></table></figure>
<p>首先是<code>createApp</code>,在vue中，每个Vue的应用都是通过createApp函数创建的一个新的应用实例。而我们引入的<code>App.vue</code>则被称为<strong>根组件</strong>，每个应用都需要一个根组件，其他组件将作为其子组件。<code>createApp(App)</code>这个代码就是将APP作为根组件生成一个应用实例，应用实例必须在调用了<code>.mount()</code> 方法后才会渲染出来。该方法接收一个“容器”参数，可以是一个实际的 DOM 元素或是一个 CSS 选择器字符串：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// app.vue</span></span><br><span class="line">&lt;div id=<span class="string">&quot;app&quot;</span>&gt;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main.js</span></span><br><span class="line">app.<span class="title function_">mount</span>(<span class="string">&#x27;#app&#x27;</span>);</span><br></pre></td></tr></table></figure>
<p>应用根组件的内容将会被渲染在容器元素里面。容器元素自己将不会被视为应用的一部分。</p>
<p>.mount() 方法应该始终在整个应用配置和资源注册完成后被调用。同时请注意，不同于其他资源注册方法，它的返回值是根组件实例而非应用实例。</p>
<h3 id="reactive"><a href="#reactive" class="headerlink" title="reactive"></a>reactive</h3><p>reactive通常用来创建<strong>对象或者数组</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; reactive &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> state = <span class="title function_">reactive</span>(&#123; <span class="attr">count</span>: <span class="number">0</span> &#125;)</span><br></pre></td></tr></table></figure>
<p>reactive使用了Proxy实现响应式，返回的是一个原始对象的Proxy，它与原始对象并不是相等的。</p>
<blockquote>
<p>对同一个原始对象调用 reactive() 会总是返回同样的代理对象，而对一个已存在的代理对象调用 reactive() 会返回其本身：</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 在同一个对象上调用 reactive() 会返回相同的代理</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">reactive</span>(raw) === proxy) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在一个代理上调用 reactive() 会返回它自己</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title function_">reactive</span>(proxy) === proxy) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>reactive的局限：</p>
<ol>
<li>仅对对象类型有效（对象、数组、map、set），对string、number、boolean这样的原始类型无效。</li>
<li><code>Vue的响应式系统是通过属性访问进行追踪的</code>，当我们用一个对象去替换了一个响应式对象，或者将响应式对象的属性进行解构时，将会失去响应式。<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> state = <span class="title function_">reactive</span>(&#123; <span class="attr">count</span>: <span class="number">0</span> &#125;)</span><br><span class="line"><span class="comment">// 这里用一个新的对象替换了&#123;count: 0&#125;，因此&#123;count: 0&#125;将会丢失响应性</span></span><br><span class="line">state = <span class="title function_">reactive</span>(&#123; <span class="attr">count</span>: <span class="number">1</span> &#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> state = <span class="title function_">reactive</span>(&#123; <span class="attr">count</span>: <span class="number">0</span> &#125;)</span><br><span class="line"><span class="comment">// n被赋值出来，失去了响应性，n的变化不会影响state</span></span><br><span class="line"><span class="keyword">let</span> n = state.<span class="property">count</span></span><br><span class="line">n++</span><br></pre></td></tr></table></figure></li>
</ol>
]]></content>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title>日常经验</title>
    <url>/2022/08/30/%E6%97%A5%E5%B8%B8%E7%BB%8F%E9%AA%8C/</url>
    <content><![CDATA[<p>今天在做写vue3的时候，要给组件的prop设置默认值，碰到一直报错的情况：<br><em>不能将类型“{}”分配给类型“(props: Readonly<Props>) =&gt; KV<unknown>”。 类型“{}”提供的内容与签名“(props: Readonly<Props>): KV<unknown>”不匹配。ts(2322)</em></p>
<span id="more"></span>
<p>代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">interface <span class="title class_">Props</span> &#123;</span><br><span class="line">  <span class="attr">modelValue</span>: <span class="variable constant_">KV</span>;</span><br><span class="line">  items?: <span class="title class_">Item</span>[];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> props = <span class="title function_">withDefaults</span>(defineProps&lt;<span class="title class_">Props</span>&gt;(),&#123;</span><br><span class="line">  <span class="comment">// 🔥 问题就出在这里 ↓ </span></span><br><span class="line">  <span class="attr">modelValue</span>:&#123;&#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>原因：<em><strong>引用型数据作为默认值, 要嵌套一层函数</strong></em>，修改为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> props = <span class="title function_">withDefaults</span>(defineProps&lt;<span class="title class_">Props</span>&gt;(),&#123;</span><br><span class="line">  <span class="attr">modelValue</span>:<span class="function">()=&gt;</span>(&#123;&#125;), <span class="comment">// 函数返回</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>redux</title>
    <url>/2022/08/27/redux/</url>
    <content><![CDATA[<p>A Predictable State Container for JS Apps是Redux官方对于Redux的描述，这句话可以这样翻译“一个专为JS应用设计的可预期的状态容器”，简单来说Redux是一个可预测的状态容器。</p>
<span id="more"></span>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><h4 id="状态（State）"><a href="#状态（State）" class="headerlink" title="状态（State）"></a>状态（State）</h4><p>state直译过来就是状态，使用React这么久了，对于state我们已经是非常的熟悉了。state不过就是一个变量，一个用来记录（组件）状态的变量。组件可以根据不同的状态值切换为不同的显示，比如，用户登录和没登录看到页面应该是不同的，那么用户的登录与否就应该是一个状态。再比如，数据加载与否，显示的界面也应该不同，那么数据本身就是一个状态。换句话说，状态控制了页面的如何显示。</p>
<p>但是需要注意的是，状态并不是React中或其他类似框架中独有的。所有的编程语言，都有状态，所有的编程语言都会根据不同的状态去执行不同的逻辑，这是一定的。所以状态是什么，状态就是一个变量，用以记录程序执行的情况。</p>
<h4 id="容器（Container）"><a href="#容器（Container）" class="headerlink" title="容器（Container）"></a>容器（Container）</h4><p>容器当然是用来装东西的，状态容器即用来存储状态的容器。状态多了，自然需要一个东西来存储，但是容器的功能却不是仅仅能存储状态，它实则是一个状态的管理器，除了存储状态外，它还可以用来对state进行查询、修改等所有操作。（编程语言中容器几乎都是这个意思，其作用无非就是对某个东西进行增删改查）</p>
<h4 id="可预测（Predictable）"><a href="#可预测（Predictable）" class="headerlink" title="可预测（Predictable）"></a>可预测（Predictable）</h4><p>可预测指我们在对state进行各种操作时，其结果是一定的。即以相同的顺序对state执行相同的操作会得到相同的结果。简单来说，Redux中对状态所有的操作都封装到了容器内部，外部只能通过调用容器提供的方法来操作state，而不能直接修改state。这就意味着外部对state的操作都被容器所限制，对state的操作都在容器的掌控之中，也就是可预测。</p>
<p>总的来说，<strong>Redux是一个稳定、安全的状态管理器</strong>。<br><img src="./redux/redux.png"></p>
<h4 id="redux与reducer、context"><a href="#redux与reducer、context" class="headerlink" title="redux与reducer、context"></a>redux与reducer、context</h4><p>Redux可以理解为是<em>reducer和context的结合体</em>，使用Redux即可管理复杂的state，又可以在不同的组件间方便的共享传递state。当然，Redux主要使用场景依然是大型应用，大型应用中状态比较复杂，如果只是使用reducer和context，开发起来并不是那么的便利，此时一个有一个功能强大的状态管理器就变得尤为的重要</p>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><blockquote>
<p>1.引入redux核心包<br>  2.创建reducer整合函数<br>  3.通过reducer对象创建store<br>  4.对store中的state进行订阅<br>  5.通过dispatch派发state的操作指令</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title class_">Redux</span>.<span class="title function_">createStore</span>(reducer, [preloadedState], [enhancer])</span><br></pre></td></tr></table></figure>
<p>createStore用来创建一个Redux中的容器对象，它需要三个参数：reducer、preloadedState、enhancer。</p>
<p>reducer是一个函数，是state操作的整合函数，每次修改state时都会触发该函数，它的返回值会成为新的state。</p>
<p>preloadedState就是state的初始值，可以在这里指定也可以在reducer中指定。</p>
<p>enhancer增强函数用来对state的功能进行扩展。<br>三个参数中，只有reducer是必须的，来看一个Reducer的示例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">countReducer</span> = (<span class="params">state = &#123;count:<span class="number">0</span>&#125;, action</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">switch</span> (action.<span class="property">type</span>)&#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;ADD&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="attr">count</span>:state.<span class="property">count</span>+<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;SUB&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> &#123;<span class="attr">count</span>:state.<span class="property">count</span>-<span class="number">1</span>&#125;;</span><br><span class="line">        <span class="attr">default</span>:</span><br><span class="line">            <span class="keyword">return</span> state</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>reducer用来整合关于state的所有操作，容器修改state时会自动调用该函数，函数调用时会接收到两个参数：<em>state</em>和<em>action</em>，state表示当前的state，可以通过该state来计算新的state。<code> state = &#123;count:0&#125;</code>这是在指定state的默认值，如果不指定，第一次调用时state的值会是undefined。也可以将该值指定为createStore()的第二个参数。action是一个普通对象，用来存储操作信息。</p>
<p>将reducer传递进createStore后，我们会得到一个store对象：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> store = <span class="title class_">Redux</span>.<span class="title function_">createStore</span>(countReducer);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>store对象创建后，对state的所有操作都需要通过它来进行：<br>读取state：store.getState()<br>修改state：store.dispatch({type:’ADD’})</p>
</blockquote>
<p>dipatch用来触发state的操作，可以将其理解为是想reducer发送任务的工具。它需要一个对象作为参数，这个对象将会成为reducer的第二个参数action，需要将操作信息设置到对象中传递给reducer。action中最重要的属性是type，type用来识别对state的不同的操作，上例中’ADD’表示增加操作，’SUB’表示减少的操作。</p>
<p>除了这些方法外，store还拥有一个subscribe方法，这个方法用来订阅state变化的信息。该方法需要一个回调函数作为参数，当store中存储的state发生变化时，回调函数会自动调用，我们可以在回调函数中定义state发生变化时所要触发的操作：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">store.<span class="title function_">subscribe</span>(<span class="function">()=&gt;</span>&#123;</span><br><span class="line">    <span class="comment">// store中state发生变化时触发</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><blockquote>
<p>1.如果state过于复杂，将会非常难以维护<br>  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以通过对state分组来解决这个问题，创建多个reducer，然后将其合并为一个<br>2.state每次操作时，都需要对state进行复制，然后再去修改<br>3.case后边的常量维护起来会比较麻烦</p>
</blockquote>
<h4 id="合并reducer"><a href="#合并reducer" class="headerlink" title="合并reducer"></a>合并reducer</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">stuReducer</span> = (<span class="params">state = &#123;</span></span><br><span class="line"><span class="params">    name: <span class="string">&#x27;孙悟空&#x27;</span>,</span></span><br><span class="line"><span class="params">    age: <span class="number">18</span>,</span></span><br><span class="line"><span class="params">    gender: <span class="string">&#x27;男&#x27;</span>,</span></span><br><span class="line"><span class="params">    address: <span class="string">&#x27;花果山&#x27;</span></span></span><br><span class="line"><span class="params">&#125;, action</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">switch</span> (action.<span class="property">type</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;SET_NAME&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                ...state,</span><br><span class="line">                <span class="attr">name</span>: action.<span class="property">payload</span></span><br><span class="line">            &#125;;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;SET_AGE&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                ...state,</span><br><span class="line">                <span class="attr">age</span>: action.<span class="property">payload</span></span><br><span class="line">            &#125;;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;SET_ADDRESS&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                ...state,</span><br><span class="line">                <span class="attr">address</span>: action.<span class="property">payload</span></span><br><span class="line">            &#125;;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;SET_GENDER&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                ...state,</span><br><span class="line">                <span class="attr">gender</span>: action.<span class="property">payload</span></span><br><span class="line">            &#125;;</span><br><span class="line">        <span class="keyword">default</span> :</span><br><span class="line">            <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">schoolReducer</span> = (<span class="params">state = &#123;</span></span><br><span class="line"><span class="params">    name: <span class="string">&#x27;花果山一小&#x27;</span>,</span></span><br><span class="line"><span class="params">    address: <span class="string">&#x27;花果山大街1号&#x27;</span></span></span><br><span class="line"><span class="params">&#125;, action</span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">switch</span> (action.<span class="property">type</span>) &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;SET_SCHOOL_NAME&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                ...state,</span><br><span class="line">                <span class="attr">name</span>: action.<span class="property">payload</span></span><br><span class="line">            &#125;;</span><br><span class="line">        <span class="keyword">case</span> <span class="string">&#x27;SET_SCHOOL_ADDRESS&#x27;</span>:</span><br><span class="line">            <span class="keyword">return</span> &#123;</span><br><span class="line">                ...state,</span><br><span class="line">                <span class="attr">address</span>: action.<span class="property">payload</span></span><br><span class="line">            &#125;;</span><br><span class="line">        <span class="keyword">default</span> :</span><br><span class="line">            <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>修改后reducer被拆分为了stuReducer和schoolReducer，拆分后在编写每个reducer时，只需要考虑当前的state数据，不再需要对无关的数据进行复制等操作，简化了reducer的编写。于此同时将不同的功能编写到了不同的reducer中，降低了代码间的耦合，方便对代码进行维护。</p>
<p>拆分后，还需要使用Redux为我们提供的函数<strong>combineReducer</strong>将多个reducer进行合并，合并后才能传递进createStore来创建store。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> reducer = <span class="title function_">combineReducers</span>(&#123;</span><br><span class="line">    <span class="attr">stu</span>:stuReducer,</span><br><span class="line">    <span class="attr">school</span>:schoolReducer</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> store = <span class="title function_">createStore</span>(reducer);</span><br></pre></td></tr></table></figure>
<p>combineReducer需要一个对象作为参数，对象的属性名可以根据需要指定，比如我们有两种数据stu和school，属性名就命名为stu和school，stu指向stuReducer，school指向schoolReducer。读取数据时，直接通过state.stu读取学生数据，通过state.school读取学校数据。</p>
]]></content>
      <categories>
        <category>React</category>
      </categories>
      <tags>
        <tag>React</tag>
      </tags>
  </entry>
  <entry>
    <title>2022年终总结</title>
    <url>/2022/12/31/2022%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<p><a name="r172O"></a></p>
<h2 id="年度回顾"><a href="#年度回顾" class="headerlink" title="年度回顾"></a>年度回顾</h2><p>最近看掘金里面，挺多人都写了年终总结，想着自己也写一份，结果拖着拖着就拖到31号了…说实话，今年是变化极大的一年，无论是我，还是这个社会。经济下行，整个互联网都进入了寒冬，看脉脉上时不时都有裁员的消息，不少应届都有被裁的，现在想来我也是运气够好，没有碰到。21年没有写年终总结，那就把这篇当成毕业后的总结吧。</p>
<span id="more"></span>
<p><a name="Pb3No"></a></p>
<h2 id="关键词：成长"><a href="#关键词：成长" class="headerlink" title="关键词：成长"></a>关键词：成长</h2><blockquote>
<p>工作一年半，要说用一个词来总结的话，我第一个想起来的词就是成长。</p>
</blockquote>
<p>工作一年半，要说用一个词来总结的话，我第一个想起来的词就是成长。不管是在工作，还是生活上都有了挺多的成长。<br><a name="FamDx"></a></p>
<h2 id="1-工作成长"><a href="#1-工作成长" class="headerlink" title="1.工作成长"></a>1.工作成长</h2><p>工作上的成长挺明显的，现在回看我刚毕业的那会，技术简直是惨不忍睹，连vue的一些基础属性用的都不是很熟…菜的离谱了属于是，感觉要不是公司缺人面试都过不了。<br />幸好，经过一年半的工作和学习，成长的挺明显的。技术方面，21年的时候由于项目的局限，主要在学习使用vue2，感觉局限比较大，没有机会去尝试新技术。还好在今年分到新组之后，开始尝试了vue3、ts、vite，也在一个小项目里面使用了react，对自己的技术提升比较大。回看这一年半，可以自信地说没有浪费时间。<br />工作方面，有了几个独立完成的项目，也担任过项目负责人(虽然不知道为啥都是紧急项目…不过总算有了点能放在简历上的经历。<br><a name="LYArv"></a></p>
<h2 id="2-生活成长"><a href="#2-生活成长" class="headerlink" title="2.生活成长"></a>2.生活成长</h2><p>在刚毕业那会儿，我生活技能为0，啥也不懂，找房子都不知道怎么整。现在毕业一年半，中间经历了一次搬家，我的生活技能也练起来了。在22年下半年，我开始学习做菜(感谢b同学送的锅，强迫我走上炸厨房的道路)，还记得第一道菜是西红柿炒鸡蛋，结果因为加多了水做成了西红柿鸡蛋汤，hhhhhh。后来做的多了，跟着菜谱（下厨房yyds）一道道做下来，已经会做好多菜了。虽然有一些还是得看着菜谱，但总算摆脱了”厨房小白“，走出了”新手村“，成就感还是挺大的，以后可以说自己一个人也饿不死了hhhhhh<br><a name="NAApW"></a></p>
<h2 id="End：总结与期待"><a href="#End：总结与期待" class="headerlink" title="End：总结与期待"></a>End：总结与期待</h2><p>删删改改，总算勉强写完了，自从高中毕业之后除了写论文就没写过这么多字的文章，看来写作能力还是得多练练。2022年是我第一个完整的工作年，想想去年7月份刚毕业的时候，好像也没过去多久，结果就已经过去一年半了，时间啊真的过的太快了。最近看到的负能量比较多，希望23年能慢慢变好，家人朋友都能够健健康康。<br />2023年我的希望：</p>
<ul>
<li><input disabled="" type="checkbox"> 多写博客，学typescript、react</li>
<li><input disabled="" type="checkbox"> github保持活跃</li>
<li><input disabled="" type="checkbox"> 可能的话买个相机，学学摄影</li>
<li><input disabled="" type="checkbox"> 找个对象吧</li>
</ul>
<p> <br />zxy           <br />2022/12/31 22:13</p>
]]></content>
      <categories>
        <category>年终总结</category>
      </categories>
      <tags>
        <tag>年终总结</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么0.1+0.2!=0.3</title>
    <url>/2023/03/08/%E4%B8%BA%E4%BB%80%E4%B9%880-1-0-2-0-3/</url>
    <content><![CDATA[<p>在开发过程遇到一个很奇怪的问题：类似</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = num1.<span class="title function_">toFixed</span>(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">const</span> b = num2.<span class="title function_">toFixed</span>(<span class="number">2</span>)</span><br><span class="line"><span class="keyword">const</span> c = a + b <span class="comment">// 某些时候c会变成x.xxxxxxxxxx</span></span><br></pre></td></tr></table></figure>
<p>明明是两个两位小数相加，为什么会变成一个这么多位数的小数？<br>在网上查了类似的现象，就发现了这个问题： 为什么<code>0.1 + 0.2 != 0.3</code>?</p>
<p>要弄清楚这个问题，首先要知道javascript是怎么保存数字的：</p>
<blockquote>
<p>JavaScript使用Number类型表示数字（整数和浮点数），遵循 IEEE 754 标准 通过64位来表示一个数字</p>
</blockquote>
<p>通过图片具体看一下数字在内存中的表示:<br><img src="../images/js_number.png"></p>
<ul>
<li>第0位：符号位，0表示正数，1表示负数(s)</li>
<li>第1位到第11位：储存指数部分（e）</li>
<li>第12位到第63位：储存小数部分（即有效数字）f<br>所以在0.1+0.2的过程中，并不是简单的0.1+0.2，计算机先是把0.1和0.2转为了二进制：<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="number">0.1</span> -&gt; <span class="number">0.0001100110011001</span>...</span><br><span class="line"><span class="number">0.2</span> -&gt; <span class="number">0.0011001100110011</span>...</span><br></pre></td></tr></table></figure>
可以看到这两个都是无穷小数，所以相加的结果不是0.3，而是<code>0.30000000000000004</code><h4 id="进制转换方法"><a href="#进制转换方法" class="headerlink" title="进制转换方法"></a>进制转换方法</h4><h5 id="十进制整数转换为二进制整数采用”除2取余，逆序排列”法。"><a href="#十进制整数转换为二进制整数采用”除2取余，逆序排列”法。" class="headerlink" title="十进制整数转换为二进制整数采用”除2取余，逆序排列”法。"></a>十进制整数转换为二进制整数采用”除2取余，逆序排列”法。</h5>具体做法是：用2整除十进制整数，可以得到一个商和余数；再用2去除商，又会得到一个商和余数，如此进行，直到商为小于1时为止，然后把先得到的余数作为二进制数的低位有效位，后得到的余数作为二进制数的高位有效位，依次排列起来。<h5 id="十进制小数转换成二进制小数"><a href="#十进制小数转换成二进制小数" class="headerlink" title="十进制小数转换成二进制小数"></a>十进制小数转换成二进制小数</h5>十进制小数转换成二进制小数采用”乘2取整，顺序排列”法。具体做法是：用2乘十进制小数，可以得到积，将积的整数部分取出，再用2乘余下的小数部分，又得到一个积，再将积的整数部分取出，如此进行，直到积中的小数部分为零，此时0或1为二进制的最后一位。或者达到所要求的精度为止。<br>然后把取出的整数部分按顺序排列起来，先取的整数作为二进制小数的高位有效位，后取的整数作为低位有效位。</li>
</ul>
]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>javascript的垃圾回收机制</title>
    <url>/2023/03/12/javascript%E7%9A%84%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<p>JavaScript是使用垃圾回收的语言，也就是说执行环境负责在代码执行时管理内存。在C和C++等语言中，跟踪内存使用对开发者来说是个很大的负担，也是很多问题的来源。JavaScript为开发者卸下了这个负担，通过自动内存管理实现内存分配和闲置资源回收。</p>
<p>基本思路很简单：<strong>确定哪个变量不会再使用，然后释放它占用的内存。这个过程是周期性的，即垃圾回收程序每隔一定时间（或者说在代码执行过程中某个预定的收集时间）就会自动运行</strong>。</p>
<p>垃圾回收过程是一个近似且不完美的方案，因为某块内存是否还有用，属于“不可判定的”问题，意味着靠算法是解决不了的。我们以函数中局部变量的正常生命周期为例。函数中的局部变量会在函数执行时存在。此时，栈（或堆）内存会分配空间以保存相应的值。函数在内部使用了变量，然后退出。此时，就不再需要那个局部变量了，它占用的内存可以释放，供后面使用。这种情况下显然不再需要局部变量了，但并不是所有时候都会这么明显。垃圾回收程序必须跟踪记录哪个变量还会使用，以及哪个变量不会再使用，以便回收内存。如何标记未使用的变量也许有不同的实现方式。不过，在浏览器的发展史上，用到过两种主要的标记策略：<strong>标记清理和引用计数</strong></p>
<h4 id="标记清理"><a href="#标记清理" class="headerlink" title="标记清理"></a>标记清理</h4><p>javaScript最常用的垃圾回收策略是<strong>标记清理</strong>。</p>
<blockquote>
<p>垃圾回收程序运行的时候，会<em>标记内存中存储的所有变量</em>（标记方法有很多种,比如，当变量进入上下文时，反转某一位；或者可以维护“在上下文中”和“不在上下文中”两个变量列表，可以把变量从一个列表转移到另一个列表）。<br>然后，它会将所有在上下文中的变量，以及被在上下文中的变量引用的变量的标记去掉。在此之后再被加上标记的变量就是待删除的了，原因是任何在上下文中的变量都访问不到它们了。随后垃圾回收程序做一次内存清理，销毁带标记的所有值并收回它们的内存。</p>
</blockquote>
<h4 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h4><p>引用计数没那么常用，思路是：</p>
<blockquote>
<p>对每个值都<em>记录它被引用的次数</em>。声明变量并给它赋一个引用值时，这个值的引用数为1。如果同一个值又被赋给另一个变量，那么引用数加1。类似地，如果保存对该值引用的变量被其他值给覆盖了，那么引用数减1。当一个值的引用数为0时，就说明没办法再访问到这个值了，因此可以安全地收回其内存了。垃圾回收程序下次运行的时候就会释放引用数为0的值的内存。</p>
</blockquote>
<p>但是，引用计数有个问题：<strong>循环引用</strong>，就是对象A有一个指针指向B，而B也引用A的情况：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// objectA和objectB通过各自的属性相互引用，意味着它们的引用数都是2，永远不会变成0</span></span><br><span class="line"><span class="comment">// 如果使用引用计数，这两个对象在函数结束后也不会被回收，内存不会被释放</span></span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">problem</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> objectA = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    <span class="keyword">let</span> objectB = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">    objectA.<span class="property">someOtherObject</span> = objectB;</span><br><span class="line">    objectB.<span class="property">anotherObject</span> = objectA;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>原始值包装类型-String、Boolean、Number</title>
    <url>/2023/03/15/%E5%8E%9F%E5%A7%8B%E5%80%BC%E5%8C%85%E8%A3%85%E7%B1%BB%E5%9E%8B-String%E3%80%81Boolean%E3%80%81Number/</url>
    <content><![CDATA[<h4 id="原始值包装类型"><a href="#原始值包装类型" class="headerlink" title="原始值包装类型"></a>原始值包装类型</h4><p>为了方便操作原始值，ECMAScript提供了3种特殊的引用类型：<strong>Boolean、Number和String</strong>。这些类型具有引用类型一样的特点，但也具有与各自原始类型对应的特殊行为。<strong>每当用到某个原始值的方法或属性时，后台都会创建一个相应原始包装类型的对象，从而暴露出操作原始值的各种方法</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="string">&quot;some text&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> s2 = s1.<span class="title function_">substring</span>(<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>在这里，s1是一个包含字符串的变量，它是一个原始值。第二行紧接着在s1上调用了substring()方法，并把结果保存在s2中。我们知道，原始值本身不是对象，因此逻辑上不应该有方法。而实际上这个例子又确实按照预期运行了。这是因为后台进行了很多处理，从而实现了上述操作。</p>
<p>具体来说，当第二行访问s1时，是以读模式访问的，也就是要从内存中读取变量保存的值。在以读模式访问字符串值的任何时候，后台都会执行以下3步：</p>
<blockquote>
<p>（1）创建一个String类型的实例；<br>  （2）调用实例上的特定方法；<br>  （3）销毁实例。</p>
</blockquote>
<p>可以把这3步想象成执行了如下3行ECMAScript代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;some text&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = s1.<span class="title function_">substring</span>(<span class="number">2</span>);</span><br><span class="line">s1 = <span class="literal">null</span>;</span><br></pre></td></tr></table></figure>
<p>这种行为可以让原始值拥有对象的行为。对布尔值和数值而言，以上3步也会在后台发生，只不过使用的是Boolean和Number包装类型而已。</p>
<p>引用类型与原始值包装类型的主要区别在于对象的生命周期。在<em>通过new实例化引用类型后，得到的实例会在离开作用域时被销毁，而自动创建的原始值包装对象则只存在于访问它的那行代码执行期间</em>。这意味着不能在运行时给原始值添加属性和方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="string">&quot;some text&quot;</span>;</span><br><span class="line">s1.<span class="property">color</span> = <span class="string">&quot;red&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(s1.<span class="property">color</span>);   <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>另外，Object构造函数作为一个工厂方法，能够根据传入值的类型返回<em>相应原始值包装类型的实例</em>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> <span class="title class_">Object</span>(<span class="string">&quot;some text&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(obj <span class="keyword">instanceof</span> <span class="title class_">String</span>);   <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<h4 id="Boolean"><a href="#Boolean" class="headerlink" title="Boolean"></a>Boolean</h4><p>Boolean是对应布尔值的引用类型。要创建一个Boolean对象，就使用Boolean构造函数并传入true或false。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> booleanObject = <span class="keyword">new</span> <span class="title class_">Boolean</span>(<span class="literal">true</span>);</span><br></pre></td></tr></table></figure>
<p>Boolean的实例会重写valueOf()方法，返回一个原始值true或false。toString()方法被调用时也会被覆盖，返回字符串”true”或”false”。不过，Boolean对象在ECMAScript中用得很少。不仅如此，它们还容易引起误会，尤其是在布尔表达式中使用Boolean对象时，比如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> falseObject = <span class="keyword">new</span> <span class="title class_">Boolean</span>(<span class="literal">false</span>);</span><br><span class="line"><span class="keyword">let</span> result = falseObject &amp;&amp; <span class="literal">true</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// true</span></span><br><span class="line"><span class="keyword">let</span> falseValue = <span class="literal">false</span>;</span><br><span class="line">result = falseValue &amp;&amp; <span class="literal">true</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>在这段代码中，我们创建一个值为false的Boolean对象。然后，在一个布尔表达式中通过&amp;&amp;操作将这个对象与一个原始值true组合起来。在布尔算术中，false &amp;&amp; true等于false。可是，这个表达式是对falseObject对象而不是对它表示的值（false）求值。<br>前面刚刚说过，所有对象在布尔表达式中都会自动转换为true，因此falseObject在这个表达式里实际上表示一个true值。那么true &amp;&amp; true当然是true。除此之外，原始值和引用值（Boolean对象）还有几个区别。<br>首先，typeof操作符对原始值返回”boolean”，但对引用值返回”object”。同样，Boolean对象是Boolean类型的实例，在使用instaceof操作符时返回true，但对原始值则返回false，如下所示：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> falseObject);                <span class="comment">// object</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> falseValue);                  <span class="comment">// boolean</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(falseObject <span class="keyword">instanceof</span> <span class="title class_">Boolean</span>); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(falseValue <span class="keyword">instanceof</span> <span class="title class_">Boolean</span>);   <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h4 id="Number"><a href="#Number" class="headerlink" title="Number"></a>Number</h4><p>Number是对应数值的引用类型。要创建一个Number对象，就使用Number构造函数并传入一个数值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> numberObject = <span class="keyword">new</span> <span class="title class_">Number</span>(<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>与Boolean类型一样，Number类型重写了valueOf()、toLocaleString()和toString()方法。<em>valueOf()方法返回Number对象表示的原始数值</em>，另外两个方法返回<em>数值字符串</em>。toString()方法可选地接收一个表示基数的参数，并返回相应基数形式的数值字符串</p>
<h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><p>String是对应字符串的引用类型。要创建一个String对象，使用String构造函数并传入一个数值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">letstringObject=<span class="title function_">newString</span>(<span class="string">&quot;helloworld&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>String对象的方法可以在所有字符串原始值上调用。3个继承的方法valueOf()、toLocaleString()和toString()都返回对象的原始字符串值。</p>
<h5 id="字符串操作方法"><a href="#字符串操作方法" class="headerlink" title="字符串操作方法"></a>字符串操作方法</h5><h6 id="1、-concat"><a href="#1、-concat" class="headerlink" title="1、 concat()"></a>1、 concat()</h6><p>concat()，用于将<strong>一个或多个字符串</strong>拼接成一个新字符串</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;hello &quot;</span>;</span><br><span class="line"><span class="keyword">let</span> result = stringValue.<span class="title function_">concat</span>(<span class="string">&quot;world&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> result2 = stringValue.<span class="title function_">concat</span>(<span class="string">&quot;world&quot;</span>, <span class="string">&quot;!&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result);        <span class="comment">// &quot;hello world&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue); <span class="comment">// &quot;hello&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result2);        <span class="comment">// &quot;hello world!&quot;</span></span><br></pre></td></tr></table></figure>
<h5 id="2、-字符串提取子字符串方法–-slice-、substr-和substring"><a href="#2、-字符串提取子字符串方法–-slice-、substr-和substring" class="headerlink" title="2、 字符串提取子字符串方法– slice()、substr()和substring()"></a>2、 字符串提取子字符串方法– slice()、substr()和substring()</h5><p>这3个方法都返回调用它们的字符串的一个子字符串，而且都接收一或两个参数。</p>
<blockquote>
<p>第一个参数表示子字符串开始的位置，第二个参数表示子字符串结束的位置。<br>对slice()和substring()而言，第二个参数是提取结束的位置（即该位置之前的字符会被提取出来）。<br>对substr()而言，第二个参数表示返回的子字符串数量。<br>任何情况下，省略第二个参数都意味着提取到字符串末尾。与concat()方法一样，slice()、substr()和substring()也不会修改调用它们的字符串，而只会返回提取到的原始新字符串值。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">slice</span>(<span class="number">3</span>));         <span class="comment">// &quot;lo world&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">substring</span>(<span class="number">3</span>));    <span class="comment">// &quot;lo world&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">substr</span>(<span class="number">3</span>));        <span class="comment">// &quot;lo world&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">slice</span>(<span class="number">3</span>, <span class="number">7</span>));     <span class="comment">// &quot;lo w&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">substring</span>(<span class="number">3</span>,<span class="number">7</span>)); <span class="comment">// &quot;lo w&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">substr</span>(<span class="number">3</span>, <span class="number">7</span>));    <span class="comment">// &quot;lo worl&quot;</span></span><br></pre></td></tr></table></figure>
<p>当某个参数是负值时，这3个方法的行为又有不同。比如，slice()方法将所有负值参数都当成字符串长度加上负参数值。而substr()方法将第一个负参数值当成字符串长度加上该值，将第二个负参数值转换为0。substring()方法会将所有负参数值都转换为0。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;hello world&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">slice</span>(-<span class="number">3</span>));           <span class="comment">// &quot;rld&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">substring</span>(-<span class="number">3</span>));      <span class="comment">// &quot;hello world&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">substr</span>(-<span class="number">3</span>));          <span class="comment">// &quot;rld&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">slice</span>(<span class="number">3</span>, -<span class="number">4</span>));        <span class="comment">// &quot;lo w&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">substring</span>(<span class="number">3</span>, -<span class="number">4</span>));   <span class="comment">// &quot;hel&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">substr</span>(<span class="number">3</span>, -<span class="number">4</span>));      <span class="comment">// &quot;&quot; (empty string)</span></span><br></pre></td></tr></table></figure>
<p>在给slice()和substr()传入负参数时，它们的返回结果相同。这是因为-3会被转换为8（长度加上负参数），实际上调用的是slice(8)和substr(8)。而substring()方法返回整个字符串，因为-3会转换为0。在第二个参数是负值时，这3个方法各不相同。slice()方法将第二个参数转换为7，实际上相当于调用slice(3, 7)，因此返回”lo w”。而substring()方法会将第二个参数转换为0，相当于调用substring(3, 0)，等价于substring(0, 3)，这是因为这个方法会将较小的参数作为起点，将较大的参数作为终点。对substr()来说，第二个参数会被转换为0，意味着返回的字符串包含零个字符，因而会返回一个空字符串。</p>
<h5 id="3、字符串位置方法–indexOf-和lastIndexOf"><a href="#3、字符串位置方法–indexOf-和lastIndexOf" class="headerlink" title="3、字符串位置方法–indexOf()和lastIndexOf()"></a>3、字符串位置方法–indexOf()和lastIndexOf()</h5><p>这两个方法从字符串中搜索传入的字符串，并返回位置（如果没找到，则返回-1）。两者的区别在于，<em>indexOf()方法从字符串开头开始查找子字符串，而lastIndexOf()方法从字符串末尾开始查找子字符串。</em></p>
<p>这两个方法都可以接收可选的第二个参数，表示开始搜索的位置。这意味着，indexOf()会从这个参数指定的位置开始向字符串末尾搜索，忽略该位置之前的字符；lastIndexOf()则会从这个参数指定的位置开始向字符串开头搜索，忽略该位置之后直到字符串末尾的字符。</p>
<h5 id="4、字符串包含方法–startsWith-、endsWith-和includes"><a href="#4、字符串包含方法–startsWith-、endsWith-和includes" class="headerlink" title="4、字符串包含方法–startsWith()、endsWith()和includes()"></a>4、字符串包含方法–startsWith()、endsWith()和includes()</h5><p>ECMAScript 6增加了3个用于判断字符串中是否包含另一个字符串的方法：startsWith()、endsWith()和includes()。这些方法都会从字符串中搜索传入的字符串，并返回一个表示是否包含的布尔值。它们的区别在于，startsWith()检查开始于索引0的匹配项，endsWith()检查开始于索引(string.length - substring.length)的匹配项，而includes()检查整个字符串：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;foobarbaz&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">startsWith</span>(<span class="string">&quot;foo&quot;</span>));   <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">startsWith</span>(<span class="string">&quot;bar&quot;</span>));   <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">endsWith</span>(<span class="string">&quot;baz&quot;</span>));     <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">endsWith</span>(<span class="string">&quot;bar&quot;</span>));     <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">includes</span>(<span class="string">&quot;bar&quot;</span>));     <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">includes</span>(<span class="string">&quot;qux&quot;</span>));     <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>startsWith()和includes()方法接收可选的第二个参数，表示开始搜索的位置。如果传入第二个参数，则意味着这两个方法会从指定位置向着字符串末尾搜索，忽略该位置之前的所有字符。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;foobarbaz&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">startsWith</span>(<span class="string">&quot;foo&quot;</span>));      <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">startsWith</span>(<span class="string">&quot;foo&quot;</span>, <span class="number">1</span>));   <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">includes</span>(<span class="string">&quot;bar&quot;</span>));         <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">includes</span>(<span class="string">&quot;bar&quot;</span>, <span class="number">4</span>));     <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>endsWith()方法接收可选的第二个参数，表示应该当作字符串末尾的位置。如果不提供这个参数，那么默认就是字符串长度。如果提供这个参数，那么就好像字符串只有那么多字符一样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> message = <span class="string">&quot;foobarbaz&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">endsWith</span>(<span class="string">&quot;bar&quot;</span>));      <span class="comment">// false</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(message.<span class="title function_">endsWith</span>(<span class="string">&quot;bar&quot;</span>, <span class="number">6</span>));   <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h5 id="5、trim-方法"><a href="#5、trim-方法" class="headerlink" title="5、trim()方法"></a>5、trim()方法</h5><p>这个方法会创建字符串的一个<em>副本</em>，删除前、后所有空格符，再返回结果。由于trim()返回的是字符串的副本，因此原始字符串不受影响，即原本的前、后空格符都会保留。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;   hello world   &quot;</span>;</span><br><span class="line"><span class="keyword">let</span> trimmedStringValue = stringValue.<span class="title function_">trim</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue);           <span class="comment">// &quot;   hello world &quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(trimmedStringValue);   <span class="comment">// &quot;hello world&quot;</span></span><br></pre></td></tr></table></figure>
<p>另外，trimLeft()和trimRight()方法分别用于从字符串开始和末尾清理空格符。</p>
<h5 id="6、repeat-方法"><a href="#6、repeat-方法" class="headerlink" title="6、repeat()方法"></a>6、repeat()方法</h5><p>这个方法接收一个整数参数，表示要将字符串复制多少次，然后返回拼接所有副本后的结果。</p>
<h5 id="7、padStart-和padEnd-方法"><a href="#7、padStart-和padEnd-方法" class="headerlink" title="7、padStart()和padEnd()方法"></a>7、padStart()和padEnd()方法</h5><p>padStart()和padEnd()方法会复制字符串，如果小于指定长度，则在相应一边填充字符，直至满足长度条件。这两个方法的第一个参数是长度，第二个参数是可选的填充字符串，默认为空格（U+0020）。</p>
<p>可选的第二个参数并不限于一个字符。如果提供了多个字符的字符串，则会将其拼接并截断以匹配指定长度。此外，如果长度小于或等于字符串长度，则会返回原始字符串。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> stringValue = <span class="string">&quot;foo&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">padStart</span>(<span class="number">8</span>, <span class="string">&quot;bar&quot;</span>)); <span class="comment">// &quot;barbafoo&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">padStart</span>(<span class="number">2</span>));          <span class="comment">// &quot;foo&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">padEnd</span>(<span class="number">8</span>, <span class="string">&quot;bar&quot;</span>));    <span class="comment">// &quot;foobarba&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(stringValue.<span class="title function_">padEnd</span>(<span class="number">2</span>));             <span class="comment">// &quot;foo&quot;</span></span><br></pre></td></tr></table></figure>
]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>js笔记-Date</title>
    <url>/2023/03/14/js%E7%AC%94%E8%AE%B0-Date/</url>
    <content><![CDATA[<p>ECMAScript的Date类型参考了Java早期版本中的java.util.Date。为此，Date类型将日期保存为自协调世界时（UTC, Universal Time Coordinated）时间1970年1月1日午夜（零时）至今所经过的毫秒数。使用这种存储格式，Date类型可以精确表示1970年1月1日之前及之后285616年的日期。</p>
<h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> now = <span class="keyword">new</span> <span class="title class_">Date</span>();</span><br></pre></td></tr></table></figure>
<h4 id="两个辅助方法"><a href="#两个辅助方法" class="headerlink" title="两个辅助方法"></a>两个辅助方法</h4><p>在不给Date构造函数传参数的情况下，创建的对象将保存当前日期和时间。要基于其他日期和时间创建日期对象，必须传入其毫秒表示（UNIX纪元1970年1月1日午夜之后的毫秒数）。ECMAScript为此提供了两个辅助方法：**Date.parse()和Date.UTC()**。</p>
<h5 id="Date-parse"><a href="#Date-parse" class="headerlink" title="Date.parse()"></a>Date.parse()</h5><p>Date.parse()方法接收一个表示日期的字符串参数，尝试将这个字符串转换为表示该日期的毫秒数。格式如下：</p>
<blockquote>
<p>“月/日/年”，如”5/23/2019”；<br>  “月名 日，年”，如”May 23, 2019”；<br>  “周几 月名 日 年 时：分：秒 时区”，如”Tue May 232019 00:00:00 GMT-0700”；<br>  ISO 8601扩展格式“YYYY-MM-DDTHH:mm:ss.sssZ”，如2019-05-23T00:00:00（只适用于兼容ES5的实现）</p>
</blockquote>
<p>如果传给Date.parse()的字符串<em>并不表示日期</em>，则该方法会返回NaN。如果直接把表示日期的字符串传给Date构造函数，那么**Date会在后台调用Date.parse()**。换句话说，下面两行代码是等价的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> someDate = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="string">&quot;May 23, 2019&quot;</span>);</span><br><span class="line">等同于</span><br><span class="line"><span class="keyword">let</span> someDate = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="title class_">Date</span>.<span class="title function_">parse</span>(<span class="string">&quot;May 23, 2019&quot;</span>));</span><br></pre></td></tr></table></figure>
<h5 id="Date-UTC"><a href="#Date-UTC" class="headerlink" title="Date.UTC()"></a>Date.UTC()</h5><p>Date.UTC()方法也返回日期的毫秒表示，但使用的是跟Date.parse()不同的信息来生成这个值。传给Date.UTC()的参数是年、零起点月数（1月是0,2月是1，以此类推）、日（1 ~ 31）、时（0 ~ 23）、分、秒和毫秒。这些参数中，只有前两个（年和月）是必需的。如果不提供日，那么默认为1日。其他参数的默认值都是0。</p>
<p>与Date.parse()一样，Date.UTC()也会被Date构造函数隐式调用，但有一个区别：<strong>这种情况下创建的是本地日期，不是GMT日期</strong></p>
<h5 id="toLocaleString-、toString-和valueOf"><a href="#toLocaleString-、toString-和valueOf" class="headerlink" title="toLocaleString()、toString()和valueOf()"></a>toLocaleString()、toString()和valueOf()</h5><p>Date类型重写了toLocaleString()、toString()和valueOf()方法。但与其他类型不同，重写后这些方法的返回值不一样。</p>
<blockquote>
<p>Date类型的toLocaleString()方法返回与浏览器运行的本地环境一致的日期和时间。这通常意味着格式中包含针对时间的AM（上午）或PM（下午），但不包含时区信息（具体格式可能因浏览器而不同）<br>toString()方法通常返回带时区信息的日期和时间，而时间也是以24小时制（0~23）表示的。<br>Date类型的valueOf()方法根本就不返回字符串，这个方法被重写后返回的是日期的毫秒表示。因此，操作符（如小于号和大于号）可以直接使用它返回的值。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="title function_">toLocaleString</span>() -<span class="number">2</span>/<span class="number">1</span>/<span class="number">2019</span> <span class="number">12</span>:<span class="number">00</span>:<span class="number">00</span> <span class="variable constant_">AM</span></span><br><span class="line"><span class="title function_">toString</span>() - <span class="title class_">Thu</span> <span class="title class_">Feb</span> <span class="number">12019</span> <span class="number">00</span>:<span class="number">00</span>:<span class="number">00</span> <span class="variable constant_">GMT</span>-<span class="number">0800</span> (<span class="title class_">Pacific</span> <span class="title class_">Standard</span> <span class="title class_">Time</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> date1 = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">2019</span>, <span class="number">0</span>, <span class="number">1</span>);     <span class="comment">// 2019年1月1日</span></span><br><span class="line"><span class="keyword">let</span> date2 = <span class="keyword">new</span> <span class="title class_">Date</span>(<span class="number">2019</span>, <span class="number">1</span>, <span class="number">1</span>);     <span class="comment">// 2019年2月1日</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(date1 &lt; date2); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(date1 &gt; date2); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h4 id="日期格式化方法"><a href="#日期格式化方法" class="headerlink" title="日期格式化方法"></a>日期格式化方法</h4><p>Date类型有几个专门用于格式化日期的方法，它们都会返回字符串：</p>
<blockquote>
<p>toDateString()显示日期中的周几、月、日、年（格式特定于实现）；<br>  toTimeString()显示日期中的时、分、秒和时区（格式特定于实现）；<br>  toLocaleDateString()显示日期中的周几、月、日、年（格式特定于实现和地区）；toLocaleTimeString()显示日期中的时、分、秒（格式特定于实现和地区）；<br>  toUTCString()显示完整的UTC日期（格式特定于实现）。</p>
</blockquote>
]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>javascript笔记</title>
    <url>/2023/03/03/js%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h3 id="async与defer"><a href="#async与defer" class="headerlink" title="async与defer"></a>async与defer</h3><p>async：可选。表示应该立即开始下载脚本，但不能阻止其他页面动作，比如下载资源或等待其他脚本加载。只对外部脚本文件有效。</p>
<p>defer：可选。表示脚本可以延迟到文档完全被解析和显示之后再执行。只对外部脚本文件有效。在IE7及更早的版本中，对行内脚本也可以指定这个属性。</p>
<blockquote>
<p>当浏览器碰到 script 脚本的时候：<br><code>1 &lt;script src=&quot;script.js&quot;&gt;&lt;/script&gt;</code><br> 没有 defer 或 async，浏览器会立即加载并执行指定的脚本，“立即”指的是在渲染该 script 标签之下的文档元素之前，也就是说不等待后续载入的文档元素，读到就加载并执行。<br> 2 <code>&lt;script async src=&quot;script.js&quot;&gt;&lt;/script&gt;</code><br> 有 async，加载和渲染后续文档元素的过程将和 script.js 的加载与执行并行进行（异步）。<br> 3 <code>&lt;script defer src=&quot;myscript.js&quot;&gt;&lt;/script&gt;</code><br>  有 defer，加载后续文档元素的过程将和 script.js 的加载并行进行（异步），但是 script.js 的执行要在所有元素解析完成之后，DOMContentLoaded 事件触发之前完成。</p>
</blockquote>
<p><img src="../images/defer_async.jpg"><br>蓝色线代表网络读取，红色线代表执行时间，这俩都是针对脚本的；绿色线代表 HTML 解析。</p>
<h3 id="let与var–块作用域与函数作用域"><a href="#let与var–块作用域与函数作用域" class="headerlink" title="let与var–块作用域与函数作用域"></a>let与var–块作用域与函数作用域</h3><p>let与var的作用差不多，最明显的区别是：<code>let声明的范围是块作用域，var声明的范围是函数作用域</code></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">&#x27;aa&#x27;</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(name); <span class="comment">// aa</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name); <span class="comment">// aa</span></span><br><span class="line"><span class="keyword">if</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> age = <span class="number">26</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(age); <span class="comment">// 26</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(age) <span class="comment">// 未定义</span></span><br></pre></td></tr></table></figure>
<p>结合代码来看，age报错了是因为作用域仅限于<code>块</code>，即<code>&#123;&#125;</code>之间，而name没有报错是因为作用域是整个函数内。如果下面这种情况</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">test</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="keyword">var</span> name = <span class="string">&#x27;aa&#x27;</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(name); <span class="comment">// aa</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name) <span class="comment">// 未定义，因为name作用域只在test函数内</span></span><br></pre></td></tr></table></figure>
<p>要清楚了解块作用域与函数作用域的区别，不能觉得var定义的变量在哪里都可以使用</p>
<h3 id="变量、缓存与作用域"><a href="#变量、缓存与作用域" class="headerlink" title="变量、缓存与作用域"></a>变量、缓存与作用域</h3><p>ECMAScript变量可以包含两种不同类型的数据：原始值和引用值。<span style="font-weight: bold;">原始值（primitive value）就是最简单的数据，引用值（reference value）则是由多个值构成的对象。</span><br>6种原始值：<code>Undefined、Null、Boolean、Number、String和Symbol</code></p>
<p>原始值和引用值的区别：</p>
<ul>
<li>原始值大小固定，因此保存在<strong>栈内存</strong>上。</li>
<li>从一个变量到另一个变量复制原始值会创建该值的第二个副本。</li>
<li>引用值是对象，存储在<strong>堆内存</strong>上。</li>
<li>包含引用值的变量实际上只包含指向相应对象的一个指针，而不是对象本身。</li>
<li>从一个变量到另一个变量复制引用值只会复制指针，因此结果是两个变量都指向同一个对象。</li>
</ul>
<p>原始值不能有属性，尽管尝试给原始值添加属性不会报错</p>
<blockquote>
<p>注意，原始类型的初始化可以只使用原始字面量形式。如果使用的是new关键字，则JavaScript会创建一个<strong>Object</strong>类型的实例，但其行为类似原始值。下面来看看这两种初始化方式的差异：</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> name1 = <span class="string">&quot;Nicholas&quot;</span>;</span><br><span class="line"><span class="keyword">let</span> name2 = <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Matt&quot;</span>);</span><br><span class="line">name1.<span class="property">age</span> = <span class="number">27</span>;</span><br><span class="line">name2.<span class="property">age</span> = <span class="number">26</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name1.<span class="property">age</span>);     <span class="comment">// undefined</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(name2.<span class="property">age</span>);     <span class="comment">// 26</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> name1); <span class="comment">// string</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">typeof</span> name2); <span class="comment">// object</span></span><br></pre></td></tr></table></figure>

<p>ECMAScript中所有函数的参数都是按值传递的。这意味着函数外的值会被复制到函数内部的参数中，就像从一个变量复制到另一个变量一样。如果是原始值，那么就跟原始值变量的复制一样，如果是引用值，那么就跟引用值变量的复制一样。</p>
<p><strong>typeof可以判断原始值，对引用值不好判断</strong>。即可以拿来判断一个变量是否为字符串、数值、布尔值或undefined，当<em>值是对象或null，那么typeof返回”object”</em><br>判断引用值： <strong>instanceof</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">用法：result= variableinstanceof constructor</span><br><span class="line"></span><br><span class="line">  console.log(person instanceof Object);   // 变量person是Object吗？</span><br><span class="line">  console.log(colors instanceof Array);    // 变量colors是Array吗？</span><br><span class="line">  console.log(pattern instanceof RegExp); // 变量pattern是RegExp吗？</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>js笔记-类</title>
    <url>/2023/03/21/js%E7%AC%94%E8%AE%B0-%E7%B1%BB/</url>
    <content><![CDATA[<h3 id="1、类定义"><a href="#1、类定义" class="headerlink" title="1、类定义"></a>1、类定义</h3><p>与函数类型相似，定义类也有两种主要方式：<strong>类声明和类表达式</strong>。这两种方式都使用class关键字加大括号：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 类声明</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;&#125;</span><br><span class="line"><span class="comment">// 类表达式</span></span><br><span class="line"><span class="keyword">const</span> <span class="title class_">Animal</span> = <span class="keyword">class</span> &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>与函数表达式类似，类表达式在它们被求值前也不能引用。不过，与函数定义不同的是，虽然函数声明可以提升，但类定义不能。另一个跟函数声明不同的地方是，函数受函数作用域限制，而类受块作用域限制。</p>
<h4 id="类的构成"><a href="#类的构成" class="headerlink" title="类的构成"></a>类的构成</h4><p>类可以包含<em>构造函数方法、实例方法、获取函数、设置函数和静态类方法</em>，但这些都不是必需的。空的类定义照样有效。类表达式的名称是可选的。在把类表达式赋值给变量后，可以通过name属性取得类表达式的名称字符串。但不能在类表达式作用域外部访问这个标识符。</p>
<h3 id="2、类构造函数"><a href="#2、类构造函数" class="headerlink" title="2、类构造函数"></a>2、类构造函数</h3><p>onstructor关键字用于在类定义块内部创建类的构造函数。方法名constructor会告诉解释器在使用new操作符创建类的新实例时，应该调用这个函数。构造函数的定义不是必需的，<em>不定义构造函数相当于将构造函数定义为空函数</em>。</p>
<p>类构造函数与构造函数的主要区别是，调用类构造函数必须使用new操作符。而普通构造函数如果不使用new调用，那么就会<strong>以全局的this（通常是window）作为内部对象</strong>。调用类构造函数时如果忘了使用new则会抛出错误。</p>
<p>为了在实例间共享方法，类定义语法把在类块中定义的方法作为原型方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 添加到this的所有内容都会存在于不同的实例上</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">locate</span> = <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;instance&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 在类块中定义的所有内容都会定义在类的原型上</span></span><br><span class="line">  <span class="title function_">locate</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;prototype&#x27;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">p.<span class="title function_">locate</span>();                     <span class="comment">// instance</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">locate</span>();   <span class="comment">// prototype</span></span><br></pre></td></tr></table></figure>

<p>可以把方法定义在类构造函数中或者类块中，但不能在类块中给原型添加原始值或对象作为成员数据：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&#x27;Jake&#x27;</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// Uncaught SyntaxError: Unexpected token</span></span><br></pre></td></tr></table></figure>

<h3 id="3、静态类方法"><a href="#3、静态类方法" class="headerlink" title="3、静态类方法"></a>3、静态类方法</h3><p>可以在类上定义静态方法。这些方法通常用于执行<strong>不特定于实例的操作</strong>，也不要求存在类的实例。与原型成员类似，静态成员每个类上只能有一个。静态类成员在类定义中使用static关键字作为前缀。在静态成员中，this引用类自身。其他所有约定跟原型成员一样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="comment">// 添加到this的所有内容都会存在于不同的实例上</span></span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">locate</span> = <span class="function">() =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;instance&#x27;</span>, <span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 定义在类的原型对象上</span></span><br><span class="line">  <span class="title function_">locate</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;prototype&#x27;</span>, <span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//定义在类本身上</span></span><br><span class="line">  <span class="title function_">staticlocate</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;class&#x27;</span>, <span class="variable language_">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> p = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">p.<span class="title function_">locate</span>();                     <span class="comment">// instance, Person &#123;&#125;</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="title function_">locate</span>();   <span class="comment">// prototype, &#123;constructor: ... &#125;</span></span><br><span class="line"><span class="title class_">Person</span>.<span class="title function_">locate</span>();               <span class="comment">// class, class Person &#123;&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="4、继承"><a href="#4、继承" class="headerlink" title="4、继承"></a>4、继承</h3><h4 id="继承基础"><a href="#继承基础" class="headerlink" title="继承基础"></a>继承基础</h4><p>ES6类支持单继承。使用<code>extends</code>关键字，就可以继承任何拥有[[Construct]]和原型的对象。很大程度上，这意味着不仅可以继承一个类，也可以继承普通的构造函数（保持向后兼容）。派生类都会通过原型链访问到类和原型上定义的方法。this的值会反映调用相应方法的实例或者类</p>
<h4 id="构造函数、HomeObject和super"><a href="#构造函数、HomeObject和super" class="headerlink" title="构造函数、HomeObject和super()"></a>构造函数、HomeObject和super()</h4><p>派生类的方法可以通过super关键字引用它们的原型。这个关键字只能在派生类中使用，而且仅限于<strong>类构造函数、实例方法和静态方法内部</strong>。在类构造函数中使用super可以调用父类构造函数。</p>
<blockquote>
<p>ES6给类构造函数和静态方法添加了内部特性[[HomeObject]]，这个特性是一个指针，指向定义该方法的对象。这个指针是自动赋值的，而且只能在JavaScript引擎内部访问。super始终会定义为[[HomeObject]]的原型。</p>
</blockquote>
<p>在使用super时要注意几个问题：</p>
<pre><code>class Vehicle &#123;
  constructor() &#123;
    super();
    // SyntaxError: &#39;super&#39; keyword unexpected
  &#125;
&#125;
</code></pre>
<ol>
<li>super只能在派生类构造函数和静态方法中使用。</li>
<li>不能单独引用super关键字，要么用它调用构造函数，要么用它引用静态方法。</li>
<li>调用super()会调用父类构造函数，并将返回的实例赋值给this。</li>
<li>super()的行为如同调用构造函数，如果需要给父类构造函数传参，则需要手动传入。</li>
<li>如果没有定义类构造函数，在实例化派生类时会调用super()，而且会传入所有传给派生类的参数。</li>
<li>在类构造函数中，不能在调用super()之前引用this。</li>
<li>如果在派生类中显式定义了构造函数，则要么必须在其中调用super()，要么必须在其中返回一个对象。</li>
</ol>
<h4 id="抽象基类"><a href="#抽象基类" class="headerlink" title="抽象基类"></a>抽象基类</h4><p>有时候可能需要定义这样一个类，它可供其他类继承，但本身不会被实例化。虽然ECMAScript没有专门支持这种类的语法，但通过new.target也很容易实现。new.target保存通过new关键字调用的类或函数。通过在实例化时检测new.target是不是抽象基类，可以阻止对抽象基类的实例化：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 抽象基类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Vehicle</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="keyword">new</span>.<span class="property">target</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">new</span>.<span class="property">target</span> === <span class="title class_">Vehicle</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&#x27;Vehicle cannot be directly instantiated&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 派生类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Bus</span> <span class="keyword">extends</span> <span class="title class_ inherited__">Vehicle</span> &#123;&#125;</span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Bus</span>();         <span class="comment">// class Bus &#123;&#125;</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Vehicle</span>();    <span class="comment">// class Vehicle &#123;&#125;</span></span><br><span class="line"><span class="comment">// Error: Vehicle cannot be directly instantiated</span></span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title>javascript阅读笔记-对象与类</title>
    <url>/2023/03/19/js%E7%AC%94%E8%AE%B0-%E5%AF%B9%E8%B1%A1%E4%B8%8E%E7%B1%BB/</url>
    <content><![CDATA[<h3 id="1、理解对象"><a href="#1、理解对象" class="headerlink" title="1、理解对象"></a>1、理解对象</h3><h4 id="1-1-对象的属性"><a href="#1-1-对象的属性" class="headerlink" title="1.1 对象的属性"></a>1.1 对象的属性</h4><p>ECMA-262使用一些内部特性来描述属性的特征。这些特性是由为JavaScript实现引擎的规范定义的。因此，开发者不能在JavaScript中直接访问这些特性。为了将某个特性标识为内部特性，规范会用两个中括号把特性的名称括起来，比如<code>[[Enumerable]]</code>。</p>
<p>属性分两种，<em><strong>数据属性和访问器属性</strong></em></p>
<h5 id="数据属性"><a href="#数据属性" class="headerlink" title="数据属性"></a>数据属性</h5><p>数据属性包含一个保存数据值的位置。值会从这个位置读取，也会写入到这个位置。数据属性有4个特性描述它们的行为。</p>
<blockquote>
<p>❑ <code>[[Configurable]]</code>：表示属性是否可以通过delete删除并重新定义，是否可以修改它的特性，以及是否可以把它改为访问器属性。默认情况下，所有直接定义在对象上的属性的这个特性都是true。<br>❑ <code>[[Enumerable]]</code>：表示属性是否可以通过for-in循环返回。默认情况下，所有直接定义在对象上的属性的这个特性都是true。<br>❑ <code>[[Writable]]</code>：表示属性的值是否可以被修改。默认情况下，所有直接定义在对象上的属性的这个特性都是true。<br>❑ <code>[[Value]]</code>：包含属性实际的值。这就是前面提到的那个读取和写入属性值的位置。这个特性的默认值为undefined。</p>
</blockquote>
<p>要修改属性的默认特性，就必须使用**Object.defineProperty()**方法。这个方法接收3个参数：要给其添加属性的对象、属性的名称和一个描述符对象。最后一个参数，即描述符对象上的属性可以包含：configurable、enumerable、writable和value，跟相关特性的名称一一对应。根据要修改的特性，可以设置其中一个或多个值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(person, <span class="string">&quot;name&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">writable</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">value</span>: <span class="string">&quot;Nicholas&quot;</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">name</span>); <span class="comment">// &quot;Nicholas&quot;</span></span><br><span class="line">person.<span class="property">name</span> = <span class="string">&quot;Greg&quot;</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">name</span>); <span class="comment">// &quot;Nicholas&quot;, name的值没有修改</span></span><br></pre></td></tr></table></figure>

<p>需要注意的是，如果把configurable设置成false，除了代表这个属性不能删除，也意味着这个属性是<strong>不可配置的</strong>。一个属性被定义为不可配置之后，<strong>就不能再变回可配置的了</strong>。再次调用Object.defineProperty()并修改任何非writable属性会导致错误：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(person, <span class="string">&quot;name&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="attr">value</span>: <span class="string">&quot;Nicholas&quot;</span></span><br><span class="line">&#125;);</span><br><span class="line"><span class="comment">// 抛出错误</span></span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(person, <span class="string">&quot;name&quot;</span>, &#123;</span><br><span class="line">  <span class="attr">configurable</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="attr">value</span>: <span class="string">&quot;Nicholas&quot;</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>xxxxxxxxxx // objectA和objectB通过各自的属性相互引用，意味着它们的引用数都是2，永远不会变成0// 如果使用引用计数，这两个对象在函数结束后也不会被回收，内存不会被释放  function problem() {    let objectA = new Object();    let objectB = new Object();    objectA.someOtherObject = objectB;    objectB.anotherObject = objectA;  }javascript</p>
<h5 id="访问器属性"><a href="#访问器属性" class="headerlink" title="访问器属性"></a>访问器属性</h5><p>访问器属性不包含数据值。相反，它们包含一个<em>获取（getter）函数</em>和一个<em>设置（setter）函数</em>，不过这两个函数不是必需的。在读取访问器属性时，会调用获取函数，这个函数的责任就是返回一个有效的值。在写入访问器属性时，会调用设置函数并传入新值，这个函数必须决定对数据做出什么修改。访问器属性有4个特性描述它们的行为。</p>
<blockquote>
<p>❑ <code>[[Configurable]]</code>：表示属性是否可以通过delete删除并重新定义，是否可以修改它的特性，以及是否可以把它改为数据属性。默认情况下，所有直接定义在对象上的属性的这个特性都是true。<br>❑ <code>[[Enumerable]]</code>：表示属性是否可以通过for-in循环返回。默认情况下，所有直接定义在对象上的属性的这个特性都是true。<br>❑ <code>[[Get]]</code>：获取函数，在读取属性时调用。默认值为undefined。<br>❑ <code>[[Set]]</code>：设置函数，在写入属性时调用。默认值为undefined。</p>
</blockquote>
<p><em>访问器属性是不能直接定义的，必须使用Object.defineProperty()。</em></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 定义一个对象，包含伪私有成员year_和公共成员edition</span></span><br><span class="line"><span class="keyword">let</span> book = &#123;</span><br><span class="line">  <span class="attr">year_</span>: <span class="number">2017</span>,</span><br><span class="line">  <span class="attr">edition</span>: <span class="number">1</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(book, <span class="string">&quot;year&quot;</span>, &#123;</span><br><span class="line">  <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">year_</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">set</span>(<span class="params">newValue</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (newValue &gt; <span class="number">2017</span>) &#123;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">year_</span> = newValue;</span><br><span class="line">      <span class="variable language_">this</span>.<span class="property">edition</span> += newValue -<span class="number">2017</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line">book.<span class="property">year</span> = <span class="number">2018</span>;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(book.<span class="property">edition</span>); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>获取函数和设置函数不一定都要定义。只定义获取函数意味着属性是只读的，尝试修改属性会被忽略。在严格模式下，尝试写入只定义了获取函数的属性会抛出错误。类似地，只有一个设置函数的属性是不能读取的，非严格模式下读取会返回undefined，严格模式下会抛出错误。</p>
<h4 id="1-2-定义多个属性"><a href="#1-2-定义多个属性" class="headerlink" title="1.2 定义多个属性"></a>1.2 定义多个属性</h4><p>ECMAScript提供了<code>Object.define-Properties()</code>方法。这个方法可以通过多个描述符一次性定义多个属性。<br>它接收两个参数：要为之添加或修改属性的对象和另一个描述符对象，其属性与要添加或修改的属性一一对应。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> book = &#123;&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">defineProperties</span>(book, &#123;</span><br><span class="line">  <span class="attr">year_</span>: &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">2017</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">edition</span>: &#123;</span><br><span class="line">    <span class="attr">value</span>: <span class="number">1</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">year</span>: &#123;</span><br><span class="line">    <span class="title function_">get</span>(<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">year_</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="title function_">set</span>(<span class="params">newValue</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (newValue &gt; <span class="number">2017</span>) &#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">year_</span> = newValue;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">edition</span> += newValue -<span class="number">2017</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="1-3-读取属性的特性"><a href="#1-3-读取属性的特性" class="headerlink" title="1.3 读取属性的特性"></a>1.3 读取属性的特性</h4><p>使用<code>Object.getOwnPropertyDescriptor()</code>方法可以取得指定属性的属性描述符。这个方法接收两个参数：属性所在的对象和要取得其描述符的属性名。返回值是一个对象，对于访问器属性包含configurable、enumerable、get和set属性，对于数据属性包含configurable、enumerable、writable和value属性。<br>ECMAScript 2017新增了<code>Object.getOwnPropertyDescriptors()</code>静态方法。这个方法实际上会<strong>在每个自有属性上调用Object.getOwnPropertyDescriptor()并在一个新对象中返回它们</strong>。</p>
<h4 id="1-4-合并对象"><a href="#1-4-合并对象" class="headerlink" title="1.4 合并对象"></a>1.4 合并对象</h4><p>ECMAScript 6专门为合并对象提供了<code>Object.assign()</code>方法。这个方法接收一个目标对象和一个或多个源对象作为参数，然后将每个源对象中可枚举（Object.propertyIsEnumerable()返回true）和自有（Object.hasOwnProperty()返回true）属性复制到目标对象。以字符串和符号为键的属性会被复制。对每个符合条件的属性，这个方法会使用源对象上的<code>[[Get]]</code>取得属性的值，然后使用目标对象上的<code>[[Set]]</code>设置属性的值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> dest, src, result;</span><br><span class="line">/＊＊</span><br><span class="line">  ＊ 简单复制</span><br><span class="line">  ＊/</span><br><span class="line">dest = &#123;&#125;;</span><br><span class="line">src = &#123; <span class="attr">id</span>: <span class="string">&#x27;src&#x27;</span> &#125;;</span><br><span class="line">result = <span class="title class_">Object</span>.<span class="title function_">assign</span>(dest, src);</span><br><span class="line"><span class="comment">// Object.assign修改目标对象</span></span><br><span class="line"><span class="comment">// 也会返回修改后的目标对象</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dest === result); <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dest ! == src);     <span class="comment">// true</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result);             <span class="comment">// &#123; id: src &#125;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dest);               <span class="comment">// &#123; id: src &#125;</span></span><br><span class="line">/＊＊</span><br><span class="line">  ＊ 多个源对象</span><br><span class="line">  ＊/</span><br><span class="line">dest = &#123;&#125;;</span><br><span class="line">result = <span class="title class_">Object</span>.<span class="title function_">assign</span>(dest, &#123; <span class="attr">a</span>: <span class="string">&#x27;foo&#x27;</span> &#125;, &#123; <span class="attr">b</span>: <span class="string">&#x27;bar&#x27;</span> &#125;);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(result); <span class="comment">// &#123; a: foo, b: bar &#125;</span></span><br><span class="line">/＊＊</span><br><span class="line">  ＊ 获取函数与设置函数</span><br><span class="line">  ＊/</span><br><span class="line">dest = &#123;</span><br><span class="line">  <span class="keyword">set</span> <span class="title function_">a</span>(<span class="params">val</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">`Invoked dest setter with param <span class="subst">$&#123;val&#125;</span>`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">src = &#123;</span><br><span class="line">  <span class="keyword">get</span> <span class="title function_">a</span>() &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;Invoked src getter&#x27;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;foo&#x27;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">assign</span>(dest, src);</span><br><span class="line"><span class="comment">// 调用src的获取方法</span></span><br><span class="line"><span class="comment">// 调用dest的设置方法并传入参数&quot;foo&quot;</span></span><br><span class="line"><span class="comment">// 因为这里的设置函数不执行赋值操作</span></span><br><span class="line"><span class="comment">// 所以实际上并没有把值转移过来</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(dest); <span class="comment">// &#123; set a(val) &#123;...&#125; &#125;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Object.assign()实际上对每个源对象执行的是浅复制。如果多个源对象都有相同的属性，则使用最后一个复制的值。</p>
</blockquote>
<p>如果赋值期间出错，则操作会中止并退出，同时抛出错误。Object.assign()没有“回滚”之前赋值的概念，因此它是一个尽力而为、可能只会完成部分复制的方法。</p>
<h3 id="2、创建对象"><a href="#2、创建对象" class="headerlink" title="2、创建对象"></a>2、创建对象</h3><h4 id="2-1-工厂模式"><a href="#2-1-工厂模式" class="headerlink" title="2.1 工厂模式"></a>2.1 工厂模式</h4><p>工厂模式是一种众所周知的设计模式，广泛应用于软件工程领域，用于抽象创建特定对象的过程。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createPerson</span>(<span class="params">name, age, job</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> o = <span class="keyword">new</span> <span class="title class_">Object</span>();</span><br><span class="line">  o.<span class="property">name</span> = name;</span><br><span class="line">  o.<span class="property">age</span> = age;</span><br><span class="line">  o.<span class="property">job</span> = job;</span><br><span class="line">  o.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> o;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person1 = <span class="title function_">createPerson</span>(<span class="string">&quot;Nicholas&quot;</span>, <span class="number">29</span>, <span class="string">&quot;Software Engineer&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> person2 = <span class="title function_">createPerson</span>(<span class="string">&quot;Greg&quot;</span>, <span class="number">27</span>, <span class="string">&quot;Doctor&quot;</span>);</span><br></pre></td></tr></table></figure>
<h4 id="2-2-构造函数模式"><a href="#2-2-构造函数模式" class="headerlink" title="2.2 构造函数模式"></a>2.2 构造函数模式</h4><p>ECMAScript中的构造函数是用于创建特定类型对象的。像Object和Array这样的原生构造函数，运行时可以直接在执行环境中使用。当然也可以自定义构造函数，以函数的形式为自己的对象类型定义属性和方法。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params">name, age, job</span>)&#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">job</span> = job;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Nicholas&quot;</span>, <span class="number">29</span>, <span class="string">&quot;Software Engineer&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> <span class="title class_">Person</span>(<span class="string">&quot;Greg&quot;</span>, <span class="number">27</span>, <span class="string">&quot;Doctor&quot;</span>);</span><br><span class="line">person1.<span class="title function_">sayName</span>();   <span class="comment">// Nicholas</span></span><br><span class="line">person2.<span class="title function_">sayName</span>();   <span class="comment">// Greg</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，Person()构造函数代替了createPerson()工厂函数。实际上，Person()内部的代码跟createPerson()基本是一样的，只是有如下区别。</p>
<blockquote>
<p>❑ 没有显式地创建对象。<br>❑ 属性和方法直接赋值给了this。<br>❑ 没有return。</p>
</blockquote>
<h4 id="2-3-原型模式"><a href="#2-3-原型模式" class="headerlink" title="2.3 原型模式"></a>2.3 原型模式</h4><p>每个函数都会创建一个prototype属性，这个属性是一个对象，包含应该由特定引用类型的实例共享的属性和方法。实际上，这个对象就是通过调用构造函数创建的对象的原型。使用原型对象的好处是，<strong>在它上面定义的属性和方法可以被对象实例共享</strong>。原来在构造函数中直接赋给对象实例的值，可以直接赋值给它们的原型。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">name</span> = <span class="string">&quot;Nicholas&quot;</span>;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">age</span> = <span class="number">29</span>;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">job</span> = <span class="string">&quot;Software Engineer&quot;</span>;</span><br><span class="line"><span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> person1 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">person1.<span class="title function_">sayName</span>(); <span class="comment">// &quot;Nicholas&quot;</span></span><br><span class="line"><span class="keyword">let</span> person2 = <span class="keyword">new</span> <span class="title class_">Person</span>();</span><br><span class="line">person2.<span class="title function_">sayName</span>(); <span class="comment">// &quot;Nicholas&quot;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person1.<span class="property">sayName</span> == person2.<span class="property">sayName</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>这里，所有属性和sayName()方法都直接添加到了Person的prototype属性上，构造函数体中什么也没有。但这样定义之后，调用构造函数创建的新对象仍然拥有相应的属性和方法。与构造函数模式不同，<em><strong>使用这种原型模式定义的属性和方法是由所有实例共享的</strong></em>。</p>
<h4 id="2-4-属性枚举顺序"><a href="#2-4-属性枚举顺序" class="headerlink" title="2.4 属性枚举顺序"></a>2.4 属性枚举顺序</h4><p><code>for-in</code>循环、<code>Object.keys()</code>、<code>Object.getOwnPropertyNames()</code>、<code>Object.getOwnProperty-Symbols()</code>以及<code>Object.assign()</code>在属性枚举顺序方面有很大区别。</p>
<blockquote>
<p><code>for-in</code>循环和<code>Object.keys()</code>的枚举顺序是不确定的，取决于JavaScript引擎，可能因浏览器而异。<br><code>Object.getOwnPropertyNames()</code>、<code>Object.getOwnPropertySymbols()</code>和<code>Object.assign()</code>的枚举顺序是确定性的。先以升序枚举数值键，然后以插入顺序枚举字符串和符号键。在对象字面量中定义的键以它们逗号分隔的顺序插入。</p>
</blockquote>
<h4 id="2-5-对象迭代"><a href="#2-5-对象迭代" class="headerlink" title="2.5 对象迭代"></a>2.5 对象迭代</h4><p>ECMAScript 2017新增了两个静态方法，用于将对象内容转换为序列化的——更重要的是可迭代的——格式。这两个静态方法Object.values()和Object.entries()接收一个对象，返回它们内容的数组。Object.values()返回对象值的数组，Object.entries()返回键/值对的数组。</p>
<h3 id="3、继承"><a href="#3、继承" class="headerlink" title="3、继承"></a>3、继承</h3><p>继承是面向对象编程中讨论最多的话题。很多面向对象语言都支持两种继承：接口继承和实现继承。前者只继承方法签名，后者继承实际的方法。接口继承在ECMAScript中是不可能的，因为函数没有签名。实现继承是ECMAScript唯一支持的继承方式，而这主要是通过原型链实现的。</p>
<h4 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h4><p>ECMA-262把原型链定义为ECMAScript的主要继承方式。其基本思想就是通过原型继承多个引用类型的属性和方法。<br>重温一下构造函数、原型和实例的关系：</p>
<blockquote>
<p>每个构造函数都有一个原型对象，原型有一个属性指回构造函数，而实例有一个内部指针指向原型。如果原型是另一个类型的实例呢？那就意味着这个原型本身有一个内部指针指向另一个原型，相应地另一个原型也有一个指针指向另一个构造函数。这样就在实例和原型之间构造了一条原型链。这就是原型链的基本构想。</p>
</blockquote>
<h4 id="原型与继承关系"><a href="#原型与继承关系" class="headerlink" title="原型与继承关系"></a>原型与继承关系</h4><p>原型与实例的关系可以通过两种方式来确定。第一种方式是使用instanceof操作符，如果一个实例的原型链中出现过相应的构造函数，则instanceof返回true。<br>第二种方式是使用isPrototypeOf()方法。原型链中的每个原型都可以调用这个方法，只要原型链中包含这个原型，这个方法就返回true。</p>
<h4 id="原型链的问题"><a href="#原型链的问题" class="headerlink" title="原型链的问题"></a>原型链的问题</h4><p>原型链虽然是实现继承的强大工具，但它也有问题。主要问题出现在原型中包含引用值的时候。前面在谈到原型的问题时也提到过，原型中包含的引用值会在所有实例间共享，这也是为什么属性通常会在构造函数中定义而不会定义在原型上的原因。在使用原型实现继承时，原型实际上变成了另一个类型的实例。这意味着原先的实例属性摇身一变成为了原型属性。下面的例子揭示了这个问题：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">SuperType</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">colors</span> = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SubType</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="comment">// 继承SuperType</span></span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">SuperType</span>();</span><br><span class="line"><span class="keyword">let</span> instance1 = <span class="keyword">new</span> <span class="title class_">SubType</span>();</span><br><span class="line">instance1.<span class="property">colors</span>.<span class="title function_">push</span>(<span class="string">&quot;black&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance1.<span class="property">colors</span>); <span class="comment">// &quot;red, blue, green, black&quot;</span></span><br><span class="line"><span class="keyword">let</span> instance2 = <span class="keyword">new</span> <span class="title class_">SubType</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance2.<span class="property">colors</span>); <span class="comment">// &quot;red, blue, green, black&quot;</span></span><br></pre></td></tr></table></figure>
<p>在这个例子中，SuperType构造函数定义了一个colors属性，其中包含一个数组（引用值）。每个SuperType的实例都会有自己的colors属性，包含自己的数组。但是，当SubType通过原型继承SuperType后，SubType.prototype变成了SuperType的一个实例，因而也获得了自己的colors属性。这类似于创建了SubType.prototype.colors属性。最终结果是，SubType的所有实例都会共享这个colors属性。这一点通过instance1.colors上的修改也能反映到instance2.colors上就可以看出来。<br>原型链的第二个问题是，子类型在实例化时不能给父类型的构造函数传参。事实上，我们无法在不影响所有对象实例的情况下把参数传进父类的构造函数。再加上之前提到的原型中包含引用值的问题，就导致原型链基本不会被单独使用。</p>
<h4 id="盗用构造函数"><a href="#盗用构造函数" class="headerlink" title="盗用构造函数"></a>盗用构造函数</h4><p>为了解决原型包含引用值导致的继承问题，一种叫作“盗用构造函数”（constructor stealing）的技术在开发社区流行起来（这种技术有时也称作“对象伪装”或“经典继承”）。基本思路很简单：<strong>在子类构造函数中调用父类构造函数</strong>。因为毕竟函数就是在特定上下文中执行代码的简单对象，所以可以使用apply()和call()方法以新创建的对象为上下文执行构造函数。来看下面的例子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">SuperType</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">colors</span> = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SubType</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">//继承SuperType</span></span><br><span class="line">  <span class="title class_">SuperType</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> instance1 = <span class="keyword">new</span> <span class="title class_">SubType</span>();</span><br><span class="line">instance1.<span class="property">colors</span>.<span class="title function_">push</span>(<span class="string">&quot;black&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance1.<span class="property">colors</span>); <span class="comment">// &quot;red, blue, green, black&quot;</span></span><br><span class="line"><span class="keyword">let</span> instance2 = <span class="keyword">new</span> <span class="title class_">SubType</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance2.<span class="property">colors</span>); <span class="comment">// &quot;red, blue, green&quot;</span></span><br></pre></td></tr></table></figure>
<p>通过使用call()（或apply()）方法，SuperType构造函数在为SubType的实例创建的新对象的上下文中执行了。这相当于新的SubType对象上运行了SuperType()函数中的所有初始化代码。结果就是每个实例都会有自己的colors属性。这种类似类中的super()。</p>
<p>相比于使用原型链，盗用构造函数的一个优点就是<em>可以在子类构造函数中向父类构造函数传参</em>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">SuperType</span>(<span class="params">name</span>)&#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SubType</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="comment">// 继承SuperType并传参</span></span><br><span class="line">  <span class="title class_">SuperType</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, <span class="string">&quot;Nicholas&quot;</span>);</span><br><span class="line">  <span class="comment">// 实例属性</span></span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = <span class="number">29</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> instance = <span class="keyword">new</span> <span class="title class_">SubType</span>();</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance.<span class="property">name</span>); <span class="comment">// &quot;Nicholas&quot;;</span></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance.<span class="property">age</span>);   <span class="comment">// 29</span></span><br></pre></td></tr></table></figure>

<p>盗用构造函数的主要缺点，也是使用构造函数模式自定义类型的问题：<em>必须在构造函数中定义方法，因此函数不能重用</em>。此外，子类也不能访问父类原型上定义的方法，因此所有类型只能使用构造函数模式</p>
<h4 id="组合继承"><a href="#组合继承" class="headerlink" title="组合继承"></a>组合继承</h4><p>组合继承（有时候也叫伪经典继承）综合了原型链和盗用构造函数，将两者的优点集中了起来。基本的思路是<strong>使用原型链继承原型上的属性和方法，而通过盗用构造函数继承实例属性</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">SuperType</span>(<span class="params">name</span>)&#123;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">name</span> = name;</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">colors</span> = [<span class="string">&quot;red&quot;</span>, <span class="string">&quot;blue&quot;</span>, <span class="string">&quot;green&quot;</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="title class_">SuperType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayName</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">name</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">SubType</span>(<span class="params">name, age</span>)&#123;</span><br><span class="line">  <span class="comment">// 继承属性</span></span><br><span class="line">  <span class="title class_">SuperType</span>.<span class="title function_">call</span>(<span class="variable language_">this</span>, name);</span><br><span class="line">  <span class="variable language_">this</span>.<span class="property">age</span> = age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 继承方法</span></span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span> = <span class="keyword">new</span> <span class="title class_">SuperType</span>();</span><br><span class="line"><span class="title class_">SubType</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">sayAge</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="variable language_">this</span>.<span class="property">age</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> instance1 = <span class="keyword">new</span> <span class="title class_">SubType</span>(<span class="string">&quot;Nicholas&quot;</span>, <span class="number">29</span>);</span><br><span class="line">instance1.<span class="property">colors</span>.<span class="title function_">push</span>(<span class="string">&quot;black&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance1.<span class="property">colors</span>);   <span class="comment">// &quot;red, blue, green, black&quot;</span></span><br><span class="line">instance1.<span class="title function_">sayName</span>();               <span class="comment">// &quot;Nicholas&quot;;</span></span><br><span class="line">instance1.<span class="title function_">sayAge</span>();                <span class="comment">// 29</span></span><br><span class="line"><span class="keyword">let</span> instance2 = <span class="keyword">new</span> <span class="title class_">SubType</span>(<span class="string">&quot;Greg&quot;</span>, <span class="number">27</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(instance2.<span class="property">colors</span>);   <span class="comment">// &quot;red, blue, green&quot;</span></span><br><span class="line">instance2.<span class="title function_">sayName</span>();               <span class="comment">// &quot;Greg&quot;;</span></span><br><span class="line">instance2.<span class="title function_">sayAge</span>();                <span class="comment">// 27</span></span><br></pre></td></tr></table></figure>

<h4 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h4><p>原型式继承的出发点是不自定义类型也可通过原型实现对象之间的信息共享。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">object</span>(<span class="params">o</span>) &#123;</span><br><span class="line">  <span class="keyword">function</span> <span class="title function_">F</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line">  F.<span class="property"><span class="keyword">prototype</span></span> = o;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title function_">F</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个object()函数会创建一个临时构造函数，将传入的对象赋值给这个构造函数的原型，然后返回这个临时类型的一个实例。本质上，object()是对传入的对象执行了一次浅复制。</p>
<p>ECMAScript 5通过增加Object.create()方法将原型式继承的概念规范化了。这个方法接收两个参数：<em>作为新对象原型的对象，以及给新对象定义额外属性的对象（第二个可选）</em>。在只有一个参数时，Object.create()与这里的object()方法效果相同：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">  <span class="attr">name</span>: <span class="string">&quot;Nicholas&quot;</span>,</span><br><span class="line">  <span class="attr">friends</span>: [<span class="string">&quot;Shelby&quot;</span>, <span class="string">&quot;Court&quot;</span>, <span class="string">&quot;Van&quot;</span>]</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> anotherPerson = <span class="title class_">Object</span>.<span class="title function_">create</span>(person);</span><br><span class="line">anotherPerson.<span class="property">name</span> = <span class="string">&quot;Greg&quot;</span>;</span><br><span class="line">anotherPerson.<span class="property">friends</span>.<span class="title function_">push</span>(<span class="string">&quot;Rob&quot;</span>);</span><br><span class="line"><span class="keyword">let</span> yetAnotherPerson = <span class="title class_">Object</span>.<span class="title function_">create</span>(person);</span><br><span class="line">yetAnotherPerson.<span class="property">name</span> = <span class="string">&quot;Linda&quot;</span>;</span><br><span class="line">yetAnotherPerson.<span class="property">friends</span>.<span class="title function_">push</span>(<span class="string">&quot;Barbie&quot;</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">friends</span>);   <span class="comment">// &quot;Shelby,Court,Van,Rob,Barbie&quot;</span></span><br></pre></td></tr></table></figure>

<p>原型式继承非常适合不需要单独创建构造函数，但仍然需要在对象间共享信息的场合。但要记住，属性中包含的引用值始终会在相关对象间共享，跟使用原型模式是一样的。</p>
<h4 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h4><p>与原型式继承比较接近的一种继承方式是<strong>寄生式继承</strong>。寄生式继承背后的思路类似于寄生构造函数和工厂模式：创建一个实现继承的函数，以某种方式增强对象，然后返回这个对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">createAnother</span>(<span class="params">original</span>)&#123;</span><br><span class="line">  <span class="keyword">let</span> clone = <span class="title function_">object</span>(original);   <span class="comment">// 通过调用函数创建一个新对象</span></span><br><span class="line">  clone.<span class="property">sayHi</span> = <span class="keyword">function</span>(<span class="params"></span>) &#123;      <span class="comment">// 以某种方式增强这个对象</span></span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;hi&quot;</span>);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> clone;              <span class="comment">// 返回这个对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>寄生式继承同样适合主要关注对象，而不在乎类型和构造函数的场景。object()函数不是寄生式继承所必需的，任何返回新对象的函数都可以在这里使用。</p>
<blockquote>
<p>注意 通过寄生式继承给对象添加函数会导致函数难以重用，与构造函数模式类似。</p>
</blockquote>
<h4 id="寄生式组合继承"><a href="#寄生式组合继承" class="headerlink" title="寄生式组合继承"></a>寄生式组合继承</h4><p>组合继承其实也存在效率问题。最主要的效率问题就是父类构造函数始终会被调用两次：<strong>一次在是创建子类原型时调用，另一次是在子类构造函数中调用</strong>。本质上，子类原型最终是要包含超类对象的所有实例属性，子类构造函数只要在执行时重写自己的原型就行了。</p>
<p>寄生式组合继承通过盗用构造函数继承属性，但使用混合式原型链继承方法。基本思路是不通过调用父类构造函数给子类原型赋值，而是取得父类原型的一个副本。说到底就是使用寄生式继承来继承父类原型，然后将返回的新对象赋值给子类原型。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">inheritPrototype</span>(<span class="params">subType, superType</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> prototype = <span class="title function_">object</span>(superType.<span class="property"><span class="keyword">prototype</span></span>);   <span class="comment">// 创建对象</span></span><br><span class="line">  prototype.<span class="property">constructor</span> = subType;                  <span class="comment">// 增强对象</span></span><br><span class="line">  subType.<span class="property"><span class="keyword">prototype</span></span> = prototype;                    <span class="comment">// 赋值对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
</search>
